<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>C++ Primer Plus | Yuchuan&#39;s Blog</title>

<link rel="shortcut icon" href="https://kimokcheon.github.io//favicon.ico?v=1695778991029">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://kimokcheon.github.io//styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Yuchuan&#39;s Blog
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://kimokcheon.github.io/post/about-me" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1695778991029" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    C++ Primer Plus
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2023-06-27 ·
                    </time>
                    
                </div>
                <div class="post-content">
                    <blockquote>
<p>因为平时经常遇到C++，以后的课程应该也免不了要用，学一下C++。</p>
<p>参考用书：C++ Primer Plus(Sixth Edition)，作者：Stephen Prata</p>
</blockquote>
<!--more-->
<p>I have learned the programming language C already, thus I'll only take down new grammars and features in C++ in my notes.</p>
<p>Also, all the Chinese versions I've found are scanned version, but I find an English version which is not scanned. Therefore I'll just use the English version. A chance to practice my English, not bad!</p>
<h1 id="chpt-1-getting-started-with-c">Chpt 1. Getting Started with C++</h1>
<p>C++ is a superset of C. C++ joins 3 separate programming categories: <strong>the procedural language, the object-oriented language and generic programming</strong>.</p>
<h3 id="c-programming-philosophy"><strong>C Programming Philosophy</strong></h3>
<p>In general, computer languages deal with two cocepts--data and algorithms. Like most mainstream languages when C was created, C is a <em>procedural</em> language. That means is emphasizes the algorithm side of programming.</p>
<p>C includes features to facilitate <em>structured programming</em> approach, making it relatively easy to read and modify a program.</p>
<p><em>Top-down</em> design was another feature of C. The idea is to break a large program into smaller, more manageable tasks. C uses programming unit called <em>functions</em> to implemente this idea.</p>
<h3 id="the-c-shift-object-oriented-programming"><strong>The C++ Shift: Object-Oriented Programming</strong></h3>
<p>Unlike procedural programming, which emphasizes algorithms, OOP emphasizes the data. The idea is to design data forms that correspond to the essential features of a problem.</p>
<p>In C++, a <em>class</em> is a specification describing such a new data form, and an <em>object</em> is a particular data structure constructed according to that plan.</p>
<p>The OOP approach to program design is to first design classes, then proceed to design a program using objects of those classes. This process of going from a lower level of organization(such as classes) to a higher level(such as program design) is called <em>bottom-up</em> programming.</p>
<p>There are other features of OOP such as information hiding, polymorphism, inheritance and etc.</p>
<h3 id="c-and-generic-programming"><strong>C++ and Generic Programming</strong></h3>
<p>The term <em>generic</em> refres to code that is type independent. Generic programming involves extending the language so that you can write a function for a generic type once and use it for a variety of actual types.</p>
<h1 id="chpt-2-setting-out-to-c">Chpt 2. Setting Out to C++</h1>
<h3 id="namespaces">Namespaces</h3>
<p>If you use <code>iostream</code> instead of <code>iostream.h</code>, you should use the following namespace directive to make the definitions in <code>iostream</code> available to your program:</p>
<pre><code class="language-cpp">using namespace std;
</code></pre>
<p>This is called a <em><code>using</code> directive</em>. Namespace support is a C++ feature that combines pre-existing code from several vendors and to help organize programs. One potential problem is that you might use two prepackaged products that both have a function called <code>wanda()</code>. The namespace facility lets a vendor pakcage its wares in a unit called a <em>namespace</em> so that you can use the name of a namespace to indecate which vendor's product you want. So Microflop Industries could place its definitions in a namespace called <code>Microflop</code>. Then <code>Microflop::wanda()</code> could denote Microflop's version of <code>wanda()</code>. Similarly, <code>Piscine::wanda()</code> could denote Piscine Corporation's version of <code>wanda()</code>.</p>
<p>Thus, you can omit the <code>using</code> directive and, instead, code in the following style:</p>
<pre><code class="language-cpp">std::cout &lt;&lt; &quot;Come up and C++ me some time.&quot;;
std::cout &lt;&lt; std::endl;
</code></pre>
<p>The following line means you can use names defined in the <code>std</code> namespace without using the <code>std::</code> prefix:</p>
<pre><code class="language-cpp">using namespace std;
</code></pre>
<h3 id="c-output-with-cout">C++ Output with <code>cout</code></h3>
<pre><code class="language-cpp">cout &lt;&lt; &quot;Come up and C++ me some time.&quot;
</code></pre>
<p>The <code>&lt;&lt;</code> notation indicates that the statement is sending the string to <code>cout</code>; the symbols point the way the information flows. <code>cout</code> is a predefined object that knows how to display a variety of things, intcluding strings, numbers and individual characters. Thus, you can say that it inserts a string into the output stream.</p>
<h3 id="using-cin">Using <code>cin</code></h3>
<pre><code class="language-cpp">cin &gt;&gt; carrots;
</code></pre>
<p>Just as C++ considers output to be a stream of characters flowing out of the program, it considers input to be a stream of characters flowing into the program.</p>
<h1 id="chpt-3-dealing-with-data">Chpt 3. Dealing with Data</h1>
<h3 id="naming-rules">Naming Rules</h3>
<p>One rule is worth noticing:</p>
<p>Names beginning with two underscore(_) characters or with an underscore character followed by an uppercase letter are reserved for use by the implementation--that is, the compiler and the resources it uses. Names beginning with a single underscore character are reserved for use as global identifiers by the implementation.</p>
<p>Using a name such as <code>__time_stop</code> or <code>_Donut</code> doesn't produce a compiler error; instead, it leads to undefined behavior. In other words, there's no telling what the result will be.</p>
<h3 id="the-sizeof-operator-and-the-climits-header-file">The <code>sizeof</code> Operator and the <code>climits</code> Header File</h3>
<p>You can apply the <code>sizeof</code> operator to a <strong>type name</strong> or to a <strong>variable name</strong>.</p>
<p>When you use the <code>sizeof</code> operator with a type name, such as <code>int</code>, you enclose the name in parentheses. But when you use the operator with the name of the variable, such as <code>n_short</code>, parentheses are optional.</p>
<p>The <code>climits</code> header file defines symbolic constants to represent type limits.</p>
<h3 id="integer-literals">Integer Literals</h3>
<p>An integer literal, or constant, is one you write out explicitly, such as 212 or 1776. C++, like C, lets you write integers in three different number bases: base 10, base 8, and base 16.</p>
<p>C++ uses the first digit or two to identify the base of a number constant:</p>
<ul>
<li>1-9: decimal(base 10)</li>
<li>0: octal(base 8)</li>
<li>0x or 0X: hexadecimal(base 16)</li>
</ul>
<p>If you want to display a value in headecimal or octal form, you can use <code>cout</code> manipulators <code>dec</code>, <code>hex</code>, and <code>oct</code> to display integers in decimal, hexadecimal, and octal formats, respectively.</p>
<h3 id="wchar_t-char16_t-and-char32_t"><code>wchar_t</code>, <code>char16_t</code> and <code>char32_t</code></h3>
<p>The <code>wchar_t</code> type is an integer type with sufficient space to represent the largest extended character set used on the system. This type has the same size and sign properties as one of the other integer types, which is called the <em>underlying</em> type. The underlying type depends on the implementation.</p>
<p>Because the sign and size of <code>wchar_t</code> can vary from one implementation to another, C++11 introduces the types <code>char16_t</code>, which is unsigned and 16 bits, and <code>char32_t</code>, which is unsigned and 32 bits. C++11 uses the <code>u</code> prefix for <code>char16_t</code> character and string constants, like <code>u'C'</code> and <code>u&quot;be good&quot;</code>. Similarly, it uses the <code>U</code> prefix for <code>char32_t</code> constants, like <code>U'R'</code> and <code>U&quot;dirty rat&quot;</code>.</p>
<h3 id="a-member-function-coutput">A member function: <code>cout.put()</code></h3>
<p>The <code>cout.put()</code> function is the first example of an important C++ OOP concept, the <em>member function</em>. A member function belongs to a class and describes a method for manipulating class data. The <code>cout</code> is an object of class <code>ostream</code>. The class has a member function named <code>put()</code>. We can use the function with a particular object of the class, such as <code>cout</code> object.</p>
<p>To use a class member function with an object of that class, simply use a period to combine the object name(<code>cout</code>) with the function name(<code>put()</code>).</p>
<blockquote>
<p>We'll learn &quot;Objects and Classes&quot; in Chapter 10. Now the only classes we have encountered are <code>istream</code> and <code>ostream</code> classes.</p>
</blockquote>
<h3 id="the-const-qualifier">The <code>const</code> qualifier</h3>
<p>C++ uses <code>const</code> to handle symbolic constants. For example, <code>const int Months = 12</code> initialized a constant named <code>Months</code> with value of 12.</p>
<h3 id="writing-floating-point-numbers">Writing Floating-Point Numbers</h3>
<p>C++ has two ways of writing floating-point numbers. The first is the custom way, like <code>3.14159</code>. The second method is called E notation, which is like <code>3.14E-6</code>(= <code>0.00000314</code>). The -6 is called an <em>exponent</em>, and the 3.14 is termed the <em>mantissa</em>.(You can use both E or e in E notation)</p>
<h3 id="floating-point-constants">Floating-Point Constants</h3>
<p>By default, floating-point constants such as 8.24 and 2.4E8 are type <code>double</code>. If we want a constant to be type <code>float</code>, we can use an <code>f</code> or <code>F</code> suffix. For type <code>long double</code>, we can use an <code>l</code> or <code>L</code> suffix.</p>
<h3 id="conversion">Conversion</h3>
<p>When you try to combine mixed types, C++ converts all the concerned types to the same type.</p>
<p>C++ empowers us to force type conversions explicitly vis the <em>type cast</em> mechanism.</p>
<p>You can use <code>(typename) value</code> or <code>typename (value)</code> to complete type cast. The former is traditional C form of type cast, whereas the second form is pure C++. The idea behind the new form is to make a type cast look ike a function call. This makes type casts for the built-in types look like the type conversions you can design for user-defined classes.</p>
<p>C++ also introduces 4 type case operators that are more restrictive in bow they can be used. Ot the four, the <code>static_cast&lt;&gt;</code> operator, can be used for converting values from one numeric type to another. Usage: <code>static_cast&lt;typename&gt; value</code>. The idea behind is to be more restrictive than the traditional type cast.</p>
<h3 id="auto-declarations-in-c11"><code>auto</code> Declarations in C++11</h3>
<p>C++11 introduces a facility that allows the compiler to deduce a type from the type of an initialization value. For this purpose it redefines the meaning of <code>auto</code>, a keyword dating back to C, but one hardly ever used.</p>
<pre><code class="language-cpp">auto n = 100;   // n is int
</code></pre>
<h1 id="chpt-4-compound-types">Chpt 4. Compound Types</h1>
<h3 id="arrays">Arrays</h3>
<p>You can use a comma-separated list of values (the <em>initialization list</em>) enclosed in braces to initialize an array, like <code>int yamcosts[3] = {20, 30, 5};</code>. However, you can <strong>only</strong> use the initialization form when defining the array. You cannot use it later(<s><code>int hands[4]; hands[4] = {5, 6, 7, 9};</code></s>) and you cannot assign one array wholesale to another(<s><code>int cards[4] = {1, 2, 3, 4}; hands = cards;</code></s>).</p>
<p>You can let the compiler counter number of elements in an array while initializing:</p>
<pre><code class="language-cpp">short things[] = {1, 5, 3, 8};
int num_elements = sizeof things / sizeof (short);
</code></pre>
<h3 id="c-style-strings">C-style Strings</h3>
<p>C++ has two ways of dealing with strings. The first is <em>C-style string</em>, like <code>char name[4] = {'S', 'a', 'm', '\0'};</code>; the second is using C++ <code>string</code> class.</p>
<p>For C-style strings, you can just initialize it without denoting the number of characters:</p>
<pre><code class="language-cpp">char fish[] = &quot;Bubbles&quot;;    // let the compiler count
</code></pre>
<p>A tricky point about <code>cin</code> is that <code>cin</code> uses whitespace(spaces, tabs, and newlines) to delineate a string. This means that <code>cin</code> only reads one word when it gets input from a character array. The program <a href="instr1.cpp">instr1.cpp</a> shows this.</p>
<p>To read input strings a line at a time instead of a word, you should use <code>istream</code>(<code>cin</code> is its object) class member functions <code>getline()</code> and <code>get()</code>. The difference is, after reading a line, <code>getline()</code> discards the newline character, whereas <code>get()</code> leaves it in the input queue.</p>
<p><code>get(name, ArSize)</code> reads input characters from keyboard and stops when input reaches its end or input is longer than <code>ArSize</code>. Note that the character <code>'\n'</code> will be left in the inpiut queue.</p>
<p>A single <code>get()</code> reads one character a time. We can use it to absort the <code>'\n'</code> character left by the above function:</p>
<pre><code class="language-cpp">cin.get(name, ArSize);      // read first line
cin.get();                  // read newline
cin.get(dessert, ArSize);   // read second line
</code></pre>
<p>Another way to use <code>get()</code> is to <em>concatenate</em>, or join, two class member functions, as follows:</p>
<pre><code class="language-cpp">cin.get(name, ArSize).get();    // concatenate member functions
</code></pre>
<p>This is possible because <code>cin.get(name, ArSize)</code> returns the <code>cin</code> object.</p>
<h3 id="use-string-class">Use <code>string</code> Class</h3>
<p>Just use</p>
<pre><code class="language-cpp">string str1;
</code></pre>
<p>to declare a string. We can also use <code>cin</code> and <code>cout</code> to assign or print the value of a string.</p>
<p>The <code>string</code> class makes it simpler for some operations to be done. For example, you can assign a string object directly to another. Also you can combine strings using the operator <code>+</code>. An advantage of using <code>string</code> class is that you don't have to worry about oversizing. <code>string</code> objects will automatically resize its size to fit in your input or your operation.</p>
<p>We can use member functions <code>size()</code> of <code>string</code> class to get the length of a string, which is equivalent to the <code>strlen()</code> function from the <code>&lt;cstring&gt;</code> header file(the older <code>&lt;string.h&gt;</code>).</p>
<p>We can use <code>getline(cin, stringname)</code> to get a string from the keyboard. Note that <code>cin</code> is an argument of the function, which indicates that this <code>getline()</code> function is not the member function method from <code>istream</code> class. It takes <code>cin</code> as an argument that tells it where to find the input. Also, there isn't an argument for the size of the string because the <code>string</code> object automatically resizes to fit the objects, as we've discussed above.</p>
<h3 id="structure-and-union">Structure and Union</h3>
<p>You've defined a strcture <code>inflatable</code>:</p>
<pre><code class="language-cpp">struct inflatable{
    char name[20];
    float volume;
    double price;
};
</code></pre>
<p>Then you can create variables of type <code>inflatable</code>:</p>
<pre><code class="language-cpp">inflatable hat;
</code></pre>
<p>Notice that you don't have to write <code>struct</code> before structure name <code>inflatable</code>, which is required in C.</p>
<p>You can use <code>string</code> class members within structure definition. Just move the <code>using</code> directive before structure definition.</p>
<p>The usage and function of <em>union</em> in C++ is the same as is in C.</p>
<h3 id="enumerations">Enumerations</h3>
<p><em>Enumeration</em> is defined as follows:</p>
<pre><code class="language-cpp">enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};
</code></pre>
<p>It establishes <code>red</code>, <code>orange</code>, <code>yellow</code>, and so on, as symbolic constants for the integer values 0-7. These constants are called <em>enumerators</em>.</p>
<p>Notice that only assignment operator is defined for enumerations. In particular, arithmetic operations are not defined. However, enumerators can be automatically converted to <code>int</code> type, but <code>int</code> types are not converted automatically to the enumeration type:</p>
<pre><code class="language-cpp">int color = blue;           // valid, spectrum type promoted to int
spectrum band;
band = 3;                   // invalid, int not converted to spectrum
color = 3 + red;            // valid, red converted to int
</code></pre>
<h3 id="allocating-memory-with-new">Allocating Memory with <code>new</code></h3>
<p>In C, you can allocate memory with the library function <code>malloc()</code>. You can still so so in C++, but C++ provides a better way: the <code>new</code> operator.</p>
<pre><code class="language-cpp">int *pn = new int;
</code></pre>
<p>The <code>new int</code> part tells the program you want some new storage suitable for holding an <code>int</code>. The <code>new</code> operator uses the type to figure out how many bytes are needed. Then it finds the memory and returns teh address.he</p>
<h3 id="freeing-memory-with-delete">Freeing memory with <code>delete</code></h3>
<p>You can free memory with <code>delete</code>:</p>
<pre><code class="language-cpp">int *ps = new int;
...
delete ps;
</code></pre>
<h3 id="use-new-to-create-dynamic-arrays">Use <code>new</code> to Create Dynamic Arrays</h3>
<pre><code class="language-cpp">int *psome = new int[10];
</code></pre>
<h3 id="use-delete-to-free-dynamic-arrays">Use <code>delete</code> to Free Dynamic Arrays</h3>
<pre><code class="language-cpp">delete [] psome;
</code></pre>
<h3 id="pointer-and-array">Pointer and Array</h3>
<p>Array name denotes the address of the starting element of the array. We have that <code>pointername[i] == *(pointername + i)</code>. Thus, in many cases we can use pointer names and array names in the same way.</p>
<p>However, there are two major differences between pointer names and array names. The first one is that array name is a constant, so you cannot change it. But pointername is changeable:</p>
<pre><code class="language-cpp">pointername = pointername + 1;      // valid
arrayname = arrayname + 1;          // not allowed
</code></pre>
<p>A second difference is that applying the <code>sizeof</code> operator to an array name yields the size of the array, even if the pointer points to an array. But applying the <code>sizeof</code> operator to array names produce the size of the array. For example:</p>
<pre><code class="language-cpp">double wages[3] = {10000.0, 20000.0, 30000.0};
double *pw = wages;                 

cout &lt;&lt; sizeof(wages) &lt;&lt; &quot; = size of wages array\n&quot;;
cout &lt;&lt; sizeof(pw) &lt;&lt; &quot; = size of pw pointer\n&quot;;
</code></pre>
<p>Running result:</p>
<pre><code>24 = size of wages array
4 = size of pw pointer
</code></pre>
<h3 id="pointer-and-string">Pointer and String</h3>
<pre><code class="language-cpp">char animal[20] = &quot;bear&quot;;           // animal holds bear
char *ps = animal;
cout &lt;&lt; animal &lt;&lt; &quot; at &quot; &lt;&lt; (int *) animal &lt;&lt; endl;
cout &lt;&lt; ps &lt;&lt; &quot; at &quot; &lt;&lt; (int *) ps &lt;&lt; endl;
</code></pre>
<p>Output:</p>
<pre><code>bear at 0x61fdf0
bear at 0x61fdf0
</code></pre>
<p>Normally, if you give <code>cout</code> a pointer, it prints an address. But if the pointer is type <code>char *</code>, <code>cout</code> displays the pointer-to string. If you want to see the address of the string, you have to type cast the pointer to another pointer type, such as <code>int *</code>, as the example above shows.</p>
<h3 id="the-vector-template-class">The <code>vector</code> Template Class</h3>
<p>The <code>vector</code> template class is similiar to the <code>string</code> class in that it is a dynamic array. Basically, it's an alternative to using <code>new</code> to create a dynamic array.</p>
<p>We'll pay attention to 5 aspects of the <code>vector</code> class:</p>
<ol>
<li>To use a <code>vector</code> class, you need to include the <code>vector</code> header file.</li>
<li>The <code>vector</code> identifier is part of the <code>std</code> namespace, so you can use a <code>using</code> directive, a <code>using</code> declaration, or <code>std::vector</code>.</li>
<li>Templates use a different syntax to indicate the type of data stored.</li>
<li>The <code>vector</code> class uses a different syntax to indicate the number of elements.</li>
</ol>
<pre><code class="language-cpp">using namespace std;
vector&lt;int&gt; vi;         // create a zero-size array of int
int n;
cin &gt;&gt; n;
vector&lt;double&gt; vd(n);   // create an array of n doubles
</code></pre>
<h3 id="the-array-template-class-c11">The <code>array</code> Template Class (C++11)</h3>
<p>Compared to <code>vector</code>, the built-in array type is a bit more efficient, but it comes at a cost of leesened convenience and safety. To solve this problem, C++11 adds the <code>array</code> template class. To create an <code>array</code> object, you need to include the <code>array</code> header file. Also it is in namespace <code>std</code>.</p>
<pre><code class="language-cpp">#include &lt;array&gt;
...
using namespace std;
array&lt;int, 5&gt; ai;           // create array object of 5 ints
array&lt;double, 4&gt; ad = {1.2, 2.1, 3.43, 4.3};
</code></pre>
<h1 id="chpt-5-loops-and-relational-expressions">Chpt 5. Loops and Relational Expressions</h1>
<h3 id="coutsetf-function"><code>cout.setf()</code> function</h3>
<p>Note that in <code>express.cpp</code>, we use <code>cout.setf(ios_base::boolalpha);</code>. This function call sets a flag that instructs <code>cout</code> to display the words <code>true</code> and <code>false</code> instead of <code>1</code> and <code>0</code>.</p>
<h3 id="for-loop">For loop</h3>
<p>C++ allows you to declare a variable in the initialization area of a <code>for</code> loop, which is not permitted in C:</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; 5; i++)
    ...
</code></pre>
<h3 id="building-a-time-delay-loop">Building a Time-Delay loop</h3>
<p>In the <code>ctime</code> header file(or the <code>time.h</code> in traditional C), a function called <code>clock()</code> returns the system time elapsed <strong>since a program started execution</strong>. Note that <code>clock()</code> does not return the time in seconds, however, and the type of its return value might be <code>long</code>, <code>unsigned long</code> or others based on your system.</p>
<p><code>ctime</code> header file provides solutions to these problems. First, It defines a symbolic constant, <code>CLOCKS_PER_SEC</code>, that equals the number of system time units per second. So dividing the system time by this value yields seconds. Or you can multiply seconds by <code>CLOCKS_PER_SEC</code> to get time in the system units.</p>
<p>Second, <code>ctime</code> establishes <code>clock_t</code> as an alias for the <code>clock()</code> return type. This means you can declare a variable as type <code>clock_t</code>, and the compiler cnverts it to <code>long</code> or <code>unsigned int</code> or whatever is the proper type for your system.</p>
<h3 id="special-note-on-cin">Special Note on <code>cin</code></h3>
<p>When reading type <code>char</code> values, just as when reading other basic types, <code>cin</code> skips over spaces and new line characters. You can refer to Listing 5.16 <code>textin1.cpp</code> to see this.</p>
<h3 id="the-end-of-fileeof-condition">The End-of-File(EOF) condition</h3>
<p>When <code>cin</code> detects the EOF, it sets two bits(the <em>eofbit</em> and the <em>failbit</em>) to 1. You can use a member function named <code>eof()</code> to see whether the eofbit has been set; the call <code>cin.eof()</code> returns the <code>bool</code> value <code>true</code> or <code>false</code> based on whether EOF has been detected or not.</p>
<p>Similarly, the <code>fail()</code> member function returns <code>true</code> if either the eofbit or the failbit has been set to <code>1</code> and <code>false</code> otherwise.</p>
<p>Note that the <code>eof()</code> and <code>fail()</code> methods report the result of the most recent attempt to read; that is, they report on the past rather than look ahead. So a <code>cin.eof()</code> or <code>cin.fail()</code> test should always follow an attempt to read. You can refer to Listing 5.18 <code>textin3.cpp</code> for this.</p>
<h3 id="bool-value-of-cin"><code>bool</code> value of <code>cin</code></h3>
<p>The <code>istream</code> class provides a function that can convert an <code>istream</code> object such as <code>cin</code> to a <code>bool</code> value. This conversion function is called when <code>cin</code> occurs in a location where a <code>bool</code> is expected, such as in the test condition of a <code>while</code> loop.</p>
<h1 id="chpt-6-branching-statements-and-logical-operators">Chpt 6. Branching Statements and Logical Operators</h1>
<h3 id="the-cctype-library-of-character-functions">The <code>cctype</code> Library of Character Functions</h3>
<p>The <code>cctype</code> header file(<code>ctype.h</code> in the older style) holds several functions that simplify such tasks as determining whether a character is an uppercase letter or a digit or punctuation. For example, the <code>isalpha(ch)</code> function returns a nonzero if <code>ch</code> is a letter and zero value otherwise. Similarly, the <code>ispunct(ch)</code> function returns a <code>true</code> value only if <code>ch</code> is a punctuation character, such as a comma or a period.</p>
<h3 id="reading-mismatch-type-into-a-variable">Reading Mismatch Type into a Variable</h3>
<p>Suppose you have the beneath lines in a program:</p>
<pre><code class="language-cpp">int n;
cin &gt;&gt; n;
</code></pre>
<p>If you enter, say, a word instead a number? Four things occur in such a mismatch:</p>
<ul>
<li>The value of <code>n</code> is left unchanged.</li>
<li>The mismatched input is left in the input queue.</li>
<li>An error flag is set in the <code>cin</code> object.</li>
<li>The call to the <code>cin</code> method, if converted to type <code>bool</code>, returns <code>false</code>.</li>
</ul>
<p>The fact that the method returns <code>false</code> means that you can use non-numeric input to terminate a number-reading loop. The fact that non-numeric input sats an error flag means that you have to reset the flag before the program can read more input. You can use the <code>clear()</code> method to reset the error flag, just use <code>cin.clear()</code>.</p>
<h3 id="simple-file-io">Simple File I/O</h3>
<p>File output is silimar to console output using <code>cout</code>. In file output:</p>
<ul>
<li>You must include the <code>fstream</code> header file.</li>
<li>The <code>fstream</code> header file defines an <code>ofstream</code> class for handling output.</li>
<li>You need to declare one or more <code>ofstream</code> variables, or objects, which you can name as you please, as long as you respect the usual naming conventions.</li>
<li>You must account for the <code>std</code> namespace; for example, you can use the <code>using</code> directive or the <code>std::</code> prefix for elements such as <code>ofstream</code>.</li>
<li>You need to associate a specific <code>ofstream</code> object with a specific file; one way to do so is to use the <code>open()</code> method.</li>
<li>When you're finished with a file, you should use the <code>close()</code> method to close the file.</li>
<li>You can use an <code>ofstream</code> object with the <code>&lt;&lt;</code> operator to output a variety of data types.</li>
</ul>
<p>Note that although the <code>iostream</code> header file provides a predefined <code>ostream</code> object called <code>cout</code>, you have to declare your own <code>ofstream</code> object, choosing a name for it and associating it with a file. Here's how you declare such objects:</p>
<pre><code class="language-cpp">ofstream outFile;           // outFile an ofstream object
ofstream fout;           // fout an ofstream object
</code></pre>
<p>You may refer to Listing 6.15 <code>outfile.cpp</code> for usage of <code>ofstream</code> class.</p>
<p>Note that when you open an existing file for output, by default it is truncated to a length of zero bytes, so <strong>the contents are lost</strong>.</p>
<p><code>ifstream</code> class is similarly designed. Note that <code>is_open()</code> method returns <code>true</code> if the file was successfully opened. You can use <code>is_open()</code> method to check whether a file was opened successfully:</p>
<pre><code class="language-cpp">ifstream inFile;
inFile.open(&quot;bowling.txt&quot;);
if (!inFile.is_open())
    exit(EXIT_FAILURE);
</code></pre>
<p>The <code>exit()</code> function is prototyped in the <code>cstdlib</code> header file, which also defines <code>EXIT_FAILURE</code> as an argument value used to communicate with the operating system. The <code>exit()</code> function terminates the program.</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://kimokcheon.github.io/post/rnn-attention-transformer-bert/" class="post-title gt-a-link">
                    RNN, Attention, Transformer, BERT
                </a>
            </div>
        

        

        

        
            <script src='https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'></script>

<style>
	div#vcomments{
		width:100%;
		max-width: 1000px;
		padding: 2.5%
	}
</style>


	<div id="vcomments"></div>

<script>
	new Valine({
		el: '#vcomments',
		appId: '',
		appKey: '',
		avatar: '',
		pageSize: 5,
		recordIp: false,
		placeholder: 'Just Go Go',
		visitor: false,
	});
</script>

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">他们都是萤火，聚在一起就成了太阳</div>
    <div class="social-container">
        
            
                <a href="https://github.com/Kimokcheon" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/people/deng-yu-chuan-4" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://kimokcheon.github.io//atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
