<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Effective Modern C++学习笔记 | Yuchuan&#39;s Blog</title>

<link rel="shortcut icon" href="https://kimokcheon.github.io//favicon.ico?v=1695778991029">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://kimokcheon.github.io//styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Yuchuan&#39;s Blog
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://kimokcheon.github.io/post/about-me" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1695778991029" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Effective Modern C++学习笔记
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2023-06-26 ·
                    </time>
                    
                </div>
                <div class="post-content">
                    <h1 id="effective-modern-c学习笔记">Effective Modern C++学习笔记</h1>
<h2 id="1-型别推导">1、型别推导</h2>
<h3 id="条款01-理解模板型别推导">条款01、理解模板型别推导</h3>
<p>函数模板形如：</p>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(ParamType param);

f(expr)//调用
</code></pre>
<p>编译器通过expr推导两个型别，即T、ParamType</p>
<h4 id="情况1paramtype-是指针或引用但不是万能引用">情况1：ParamType 是指针或引用，但不是万能引用</h4>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(T&amp; param)
//void f(T* param)
const char name[]=&quot;Lucas&quot;;
f(name);//T:const char [6],param:const char&amp; [6]
template&lt;typename T,std::size_t N&gt;
constexpr std::size_t arraySize(T (&amp;)[N])noexcept{//数组形参未取名字
    return N;
}
std::array&lt;int,arraySize(name)&gt;map;//编译期推导元素个数
</code></pre>
<p>特性：T保留常量性，忽略引用性。可以推导出数组型别！</p>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(const T&amp; param)
</code></pre>
<p>此时T型别推导不会包含const</p>
<h4 id="情况二paramtype-是万能引用">情况二：ParamType 是万能引用</h4>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(T&amp;&amp; parma)

int x=27;
const int cx=x;
const int&amp; rx=x;
f(x);//T:int&amp;,param:int&amp;
f(cx);//T:const int&amp;,param:const int&amp;
f(rx);//T:const int&amp;,param:const int&amp;
f(27);//T:int,param:int &amp;&amp;
</code></pre>
<h4 id="情况三paramtype-既非指针也非引用">情况三：ParamType 既非指针也非引用</h4>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(T param);

int x=27;
const int cx=x;
const int&amp; rx=x;
const char* const ptr=&quot;Fun with pointers&quot;;
f(x);//T:int,param:int
f(cx);//T:int,param:int
f(rx);//T:int,param:int
f(ptr);//T:const char *,param:const char *
</code></pre>
<p>忽略const和volatile，但保留指针指向对象的cv特性。数组与函数都会推导为对应指针。</p>
<h3 id="条款2理解auto型别推导">条款2：理解auto型别推导</h3>
<ol>
<li>auto相当于T，变量的型别相当于ParamType</li>
</ol>
<p>​	唯一区别：auto会假定用大括号括起的初始化表达式代表一个std::initiallizer_list，但模板型别推导不会。</p>
<ol start="2">
<li>在函数返回值以及lambda式形参中使用auto，意思是使用模板型别推导。</li>
</ol>
<h3 id="条款3理解decltype">条款3：理解decltype</h3>
<ol>
<li>
<p>decltype返回给定名字或表达式的确切型别</p>
</li>
<li>
<p>主要用途在于声明那些返回值型别依赖于形参型别的函数模板</p>
<pre><code class="language-c++">template&lt;typename Container,typename Index&gt;
decltype(auto) authAndAccess(Container&amp;&amp; c,Index i){
	authenticateUser();
    return std::forward&lt;Container&gt;(c)[i];
}
</code></pre>
</li>
</ol>
<h2 id="2-auto">2、auto</h2>
<h3 id="条款5优先选用auto而非显式型别声明">条款5：优先选用auto，而非显式型别声明</h3>
<ol>
<li>用例：</li>
</ol>
<pre><code class="language-c++">auto derefLess = [](const auto&amp; p1,const auto&amp; p2){
    return *p1&lt;*p2;
}
</code></pre>
<pre><code class="language-c++">std::unordered_map&lt;std::string,int&gt;m;
for(const auto&amp;p:m){...}
</code></pre>
<ol start="2">
<li>
<p>但是要防止写出：</p>
<pre><code class="language-c++">auto someVar = “隐形”代理型别表达式;
//例：
std::vector&lt;bool&gt; features(const Widget&amp; w);
Widget w;
auto highPriority=features(w)[5];//highPriority类型为std::vector&lt;bool&gt;::reference而不是bool!
//强制转换解决
auto sum=static_cast&lt;Matrix&gt;(m1+m2+m3+m4);
</code></pre>
</li>
</ol>
<h2 id="3-转向现代c">3、转向现代C++</h2>
<h3 id="条款7在创建对象时注意区分和">条款7：在创建对象时注意区分（）和 {}</h3>
<ol>
<li>
<p>{}特性：统一性、禁止隐式窄化型别转换、调用没有形参的构造函数</p>
</li>
<li>
<p>与（）典型区别</p>
<pre><code class="language-c++">std::vector&lt;int&gt; v1(10,20);//10个元素，值全为20
std::vector&lt;int&gt; v2{10,20};//2个元素，10、20
</code></pre>
</li>
</ol>
<h3 id="条款8优先选用nullptr">条款8：优先选用nullptr</h3>
<ol>
<li>相对于0或NULL，优先选用nullptr</li>
<li>避免在整型和指针型别之间重载</li>
</ol>
<h3 id="条款9优先选用别名声明而非typedef">条款9：优先选用别名声明，而非typedef</h3>
<ol>
<li>typedef不支持模板化，但using支持</li>
</ol>
<h3 id="条款10优先选用限定作用域的枚举型别而非不限作用域的枚举型别">条款10：优先选用限定作用域的枚举型别，而非不限作用域的枚举型别</h3>
<pre><code class="language-c++">enum class Color{black,white,red};
auto white=false;
Color c=Color::white;
auto c=Color::white;
</code></pre>
<p>限定作用域的枚举型别总是可以进行前置声明。</p>
<h3 id="条款11优先选用删除函数而非private未定义函数">条款11：优先选用删除函数，而非private未定义函数</h3>
<pre><code class="language-c++">template&lt;&gt;
void processPointer&lt;void&gt;(void*)=delete;
</code></pre>
<p>任何函数都可以删除，包括非成员函数和模板具现。</p>
<h3 id="条款12为意在改写的函数添加override声明意在禁止用作基类的函数添加final声明">条款12：为意在改写的函数添加override声明，意在禁止用作基类的函数添加final声明</h3>
<h3 id="条款13优先选用const_iterator">条款13：优先选用const_iterator</h3>
<pre><code class="language-c++">template&lt;typename C,typename V&gt;
void findAndInsert(C&amp; container,const V&amp; targetVal,const V&amp; insertVal){
    using std::cbegin;
    using std:cend;
    auto it=std::find(cbegin(container),cend(container),targetVal);
    container.insert(it,insertVal);
}
</code></pre>
<h3 id="条款14只要函数不会发射异常就为其加上noexcept声明">条款14：只要函数不会发射异常，就为其加上noexcept声明</h3>
<h3 id="条款15只要有可能使用constexpr就使用它">条款15：只要有可能使用constexpr，就使用它</h3>
<h3 id="条款16保证const成员函数的线程安全性">条款16：保证const成员函数的线程安全性</h3>
<ol>
<li>
<p>引入mutex防止data race</p>
<pre><code class="language-c++">class Polynomial{
public:
	using RootsType = std::vector&lt;double&gt;;
    RootsType roots() const{
		std::lock_guard&lt;std::mutex&gt;g(m);
        if(!rootAreValid){
            ...
            rootsAreValid = true;
        }
        return rootVals;
    }
private:
    mutable std::mutex m;
    mutable bool rootsAreValid{false};
    mutable RootsType rootVals{};
};
</code></pre>
</li>
<li>
<p>使用std::atomic成本更低，但如果有两个或更多变量或内存区域需要作为一整个单位进行操作时，就要使用互斥量。</p>
<pre><code class="language-c++">class Point{
public:
    ...
    double distanceFromOrigin() const noexcept{
        ++callCount;
        return std::sqrt((x*x)+(y*y));
    }
private:
    mutable std::atomic&lt;unsigned&gt; callCount{0};
    double x,y;
};
</code></pre>
</li>
</ol>
<h2 id="4智能指针">4.智能指针</h2>
<h3 id="条款18使用stdunique_ptr管理具备专属所有权的资源">条款18：使用std:unique_ptr管理具备专属所有权的资源</h3>
<ol>
<li>std::unique_ptr是小巧、高速、具备只移型别的智能指针，对托管资源实施专属所有权语义。</li>
<li>可以直解通过std::shared_ptr&lt;…&gt;强制转换</li>
</ol>
<h3 id="条款19使用stdshared_ptr管理具备共享所有权资源">条款19：使用std::shared_ptr管理具备共享所有权资源</h3>
<ol>
<li>share_ptr是unique_ptr尺寸的两倍，还会带来控制块的开销，并要求原子化的引用计数操作。</li>
<li>避免使用裸指针型别的变量创建std::shared_ptr</li>
</ol>
<h3 id="条款20对于类似stdshared_ptr但有可能空悬的指针使用stdweak_ptr">条款20：对于类似std::shared_ptr但有可能空悬的指针使用std::weak_ptr</h3>
<ol>
<li>std::weak_ptr可能的用武之地包括缓存、观察者列表，以及避免std::shared_ptr指针环路（非严格继承谱系）</li>
</ol>
<h3 id="条款21优先选用stdmake_unique和stdmake_shared而非直接使用new">条款21：优先选用std::make_unique和std::make_shared，而非直接使用new</h3>
<pre><code class="language-c++">auto upw1(std::make_unique&lt;Widget&gt;());
auto spw1(std::make_shared&lt;Widget&gt;());
</code></pre>
<p>在需要定制删除器以及期望直接传递大括号初始化物时，不建议使用make系列函数</p>
<h3 id="条款22使用pimpl习惯用法时将特殊成员函数的定义放到实现文件中">条款22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中</h3>
<ol>
<li>
<p>Pimpl技巧：把某类的数据成员用一个指涉到某实现类的指针替代，然后把原来在主类中的数据成员放置到实现类中，并通过指针间接访问这些数据成员。</p>
<pre><code class="language-c++">class Widget{   //位于头文件“widget.h&quot;中
public:
    widget();
    ~widget();
    widget(Widget&amp;&amp; rhs);
    Widget&amp; operator=(Widget&amp;&amp; rhs);
    Widget(const Widget&amp; rhs);
    Widget&amp; operator=(const Widget&amp; rhs);
private:
    struct Impl;
    std::unique_ptr&lt;Impl&gt;pImpl;
}

#include &quot;widget.h&quot;   //位于头文件“widget.cpp”中
#include &quot;gadget.h&quot;
#include &lt;string&gt;
#include &lt;vector&gt;

struct Widget::Impl{...};
Widget::Widget():pImpl(std::make_unique&lt;Impl&gt;()){};
Widget::~Widget()=default;
Widget::Widget(Widget&amp;&amp; rhs)=default;
Widget&amp; Widget::operator=(Widget&amp;&amp; rhs)=default;
Widget::Widget(const Widget&amp; rhs):pImpl(std::make_unique&lt;Impl&gt;(*rhs.pImpl)){}
Widget&amp; Widget::operator=(const Widget&amp;rhs){
    *pImpl=*rhs.pImpl;
    return *this;
}
</code></pre>
<p>使用#include指令包含widget.h后客户代码如下:</p>
<pre><code class="language-c++">#include &quot;widget.h&quot;
Widget w1;
auto w2(std::move(w1));
w1=std::move(w2);
...
</code></pre>
</li>
</ol>
<h2 id="5-右值引用-移动语义和完美转发">5、右值引用、移动语义和完美转发</h2>
<h3 id="条款23理解stdmove和stdforward">条款23：理解std::move和std::forward</h3>
<ol>
<li>std::move和std::forward都仅仅执行强制型别转换的函数模板，std::move无条件将实参强制转换为右值，而std::forword则仅在某个特定条件满足时才执行同一个强制转换，在运行期，两者都不会做任何操作。</li>
<li>move:如果想让某个对象执行移动操作的能力，则不要将其声明为常量</li>
</ol>
<pre><code class="language-c++">template&lt;typename T&gt;
decltype(auto) move(T&amp;&amp; param){
    using ReturnType = remove_reference_t&lt;T&gt;&amp;&amp;;
    return static_cast&lt;ReturnType&gt;(param);
}
</code></pre>
<ol start="3">
<li>forward:当且仅当用来初始化param的实参是个右值的条件下，把param强制转换成右值型别。</li>
</ol>
<pre><code class="language-c++">template&lt;typename T&gt;
T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp; param){
    return static_cast&lt;T&amp;&amp;&gt;(param);
}
</code></pre>
<h3 id="条款25针对右值引用实施stdmove针对万能引用实施stdforward">条款25：针对右值引用实施std::move，针对万能引用实施std::forward</h3>
<ol>
<li>针对右值引用的最后一次使用实施move，针对万能引用的最后一次使用实施forward</li>
<li>若局部对象可能适用于返回值优化，则请勿针对其实施move或forward</li>
</ol>
<h3 id="条款26避免依万能引用型别进行重载">条款26：避免依万能引用型别进行重载</h3>
<ol>
<li>把万能引用作为重载候选型别，几乎总会让该重载版本在始料未及的情况下被调用到</li>
<li>完美转发构造函数的问题尤为严重，它们会劫持派生类中对基类的复制和移动构造函数的调用</li>
<li>替代方案包括使用彼此不同的函数名字、传递const T&amp;型别的形参、传值和标签分派</li>
</ol>
<h3 id="条款28理解引用折叠">条款28：理解引用折叠</h3>
<ol>
<li>如果任一引用为左值引用，则结果为左值引用。否则为右值引用。（两&amp;消去）</li>
</ol>
<h3 id="条款30熟悉完美转发的失败情形">条款30：熟悉完美转发的失败情形</h3>
<ol>
<li>大括号初始化物。但可以通过auto声明局部变量，然后将该局部变量传递给转发函数</li>
<li>0和NULL作空指针，可以改为nullptr</li>
<li>仅有声明的整型static const 成员变量</li>
<li>重载的函数名字和模板名字</li>
<li>位域</li>
</ol>
<h2 id="6-lambda-表达式">6、lambda 表达式</h2>
<h3 id="条款31避免默认捕获模式">条款31：避免默认捕获模式</h3>
<ol>
<li>
<p>按引用捕获可能导致空悬引用。一旦由lambda式所创建的闭包越过了该局部变量或形参的生命期，那么闭包内的引用就会空悬。</p>
<pre><code class="language-c++">template&lt;typename C&gt;
void workWithContainer(const C&amp; container){
    auto calc1=computeSomeValue1();
    auto calc2=computeSomeValue2();
    auto divisor=computeDivisor(calc1,calc2);
    using std::begin;
    using std::end;
	if(std::all_of(begin(container),end(container),   //注意不能超过divisor的生命周期
                   [&amp;](const auto&amp; value){
                       return value%divisor==0;
                   })
      ){
        ...
    }
    else {
        ...
    }
}
</code></pre>
</li>
<li>
<p>按值捕获只能针对于在创建lambda式的作用域可见的非静态局部变量（包括形参），依然可能会空悬。</p>
<pre><code class="language-c++">filters.emplace_back([=](int value){return value%divisor==0;});
</code></pre>
</li>
</ol>
<h3 id="条款32使用初始化捕获将对象移入闭包">条款32：使用初始化捕获将对象移入闭包</h3>
<pre><code class="language-c++">auto func=[pw=std::make_unique&lt;widget&gt;()]{
    return pw-&gt;isValidated()&amp;&amp;pw-&gt;isArchived();
};
</code></pre>
<h3 id="条款33对auto型别的形参使用decltype以stdforward之">条款33：对auto&amp;&amp;型别的形参使用decltype，以std::forward之</h3>
<pre><code class="language-c++">auto f=[](auto&amp;&amp; param){
    return func(normalize(std::forward&lt;decltype(param)&gt;(param)));
};
auto f=[](auto&amp;&amp;... params){
    return func(normalize(std::forward&lt;decltype(params)&gt;(params)...));
};//接受多个形参

</code></pre>
<p>补充：c++20起lambda可以使用模板</p>
<p>![2022-09-25 19-44-07 的屏幕截图](/home/rack/笔记/Effective C++/2022-09-25 19-44-07 的屏幕截图.png)</p>
<pre><code class="language-c++">// generic lambda, operator() is a template with two parameters
auto f = []&lt;class T&gt;(T a, auto&amp;&amp; b) { return a &lt; b; };
 
// generic lambda, operator() is a template with one parameter pack
auto f = []&lt;typename... Ts&gt;(Ts&amp;&amp;... ts)
{
    return func(std::forward&lt;Ts&gt;(ts)...);
};
</code></pre>
<h2 id="7-并发api">7、并发API</h2>
<h3 id="条款35优先选用基于任务而非基于线程的程序设计">条款35：优先选用基于任务而非基于线程的程序设计</h3>
<p>基于线程：</p>
<pre><code class="language-c++">int doAsyncWork();
std::thread t(doAsyncWork);
</code></pre>
<p>基于任务：</p>
<pre><code class="language-c++">auto fut = std::async(doAsyncWork);
</code></pre>
<h3 id="条款36如果异步是有必要的则指定stdlaunchasync">条款36：如果异步是有必要的，则指定std::launch::async</h3>
<ul>
<li>std::launch::async启动策略意味着函数必须以异步方式运行，即在另一线程之上执行</li>
<li>std::launch::deferred启动策略意味函数只会在std::async所返回的期值的get或wait得到调用时才运行。</li>
<li>std::async的默认启动策略是上述两者进行或运算的结果</li>
</ul>
<pre><code class="language-c++">auto fut = std::async(std::launch::async, f);
</code></pre>
<h3 id="条款40对并发使用stdatomic对特种内存使用volatile">条款40：对并发使用std::atomic，对特种内存使用volatile</h3>
<ol>
<li>
<p>将第一个任务的可用性传递给第二个任务</p>
<pre><code class="language-c++">std::atomic&lt;bool&gt; valAvailable(false);
auto imptValue = computeImportantValue();
valAvailable = true;
</code></pre>
<p>std::atomic型别对象的运用会对代码可以如何重新排序施加限制</p>
<p>std::atimic的复制操作被删除了，且移动操作没有显式声明，可以从x中取值并置入y中</p>
<pre><code class="language-c++">std::atomic&lt;int&gt; x;
std::atomic&lt;int&gt; y(x.load());
y.store(x.load());
</code></pre>
</li>
<li>
<ul>
<li>常规内存：如果你向某个内存位置写入例值，该值会一直保留在那里，直到它被覆盖为止</li>
</ul>
<pre><code class="language-c++">auto y = x;
y = x;
x = 10;
x = 20;
</code></pre>
<p>编译器可以径自把这段代码视作如下代码</p>
<pre><code class="language-c++">auto y = x;
x = 20;
</code></pre>
<ul>
<li>
<p>特种内存：常用于内存映射I/O，如于外部设备（外部传感器、显示器、打印机和网络端口）通信，而非读入或写入常规内存（即RAM）</p>
<p>而volatile的用处就是告诉编译器，正在处理的是特种内存，不要对在此内存上的操作做任何优化。</p>
</li>
</ul>
</li>
</ol>
<h2 id="8-微调">8、微调</h2>
<h3 id="条款41针对可复制的形参在移动成本低并且一定会被复制的前提下-考虑将其按值传递">条款41：针对可复制的形参，在移动成本低并且一定会被复制的前提下， 考虑将其按值传递</h3>
<ol>
<li>
<p>经由构造复制形参的成本可能比经由赋值复制形参高出很多。</p>
</li>
<li>
<p>按值传递肯定会导致切片问题，所有基类型别特别不适用于按值传递！！！</p>
<pre><code class="language-c++">class Widget{...};
class SpecialWidget: public Widget {...};
void processWidget(Widget w);
SpecialWidget sw;
processWidget(sw);   //processWidget看到的只是一个Widget而非SpecialWidget类型的对象！
</code></pre>
</li>
</ol>
<h3 id="条款42考虑置入而非插入">条款42：考虑置入而非插入</h3>
<ol>
<li>置入函数在以下几个前提成立时，极有可能会运行得更快：
<ul>
<li>待添加的值是以构造而非赋值方式加入容器</li>
<li>传递的实参型别与容器持有之物的型别不同</li>
<li>容器不会由于存在重复值而拒绝待添加的值</li>
</ul>
</li>
<li>置入函数可能会执行在插入函数中会被拒绝的型别转换，所以使用置入函数时，要特别小心去保证传递了正确的实参。</li>
</ol>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://kimokcheon.github.io/post/effective-cxue-xi-bi-ji/" class="post-title gt-a-link">
                    Effective C++学习笔记
                </a>
            </div>
        

        

        

        
            <script src='https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'></script>

<style>
	div#vcomments{
		width:100%;
		max-width: 1000px;
		padding: 2.5%
	}
</style>


	<div id="vcomments"></div>

<script>
	new Valine({
		el: '#vcomments',
		appId: '',
		appKey: '',
		avatar: '',
		pageSize: 5,
		recordIp: false,
		placeholder: 'Just Go Go',
		visitor: false,
	});
</script>

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">他们都是萤火，聚在一起就成了太阳</div>
    <div class="social-container">
        
            
                <a href="https://github.com/Kimokcheon" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/people/deng-yu-chuan-4" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://kimokcheon.github.io//atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
