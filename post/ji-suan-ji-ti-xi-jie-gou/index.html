<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>计算机体系结构 | Yuchuan&#39;s Blog</title>

<link rel="shortcut icon" href="https://kimokcheon.github.io//favicon.ico?v=1695778991029">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://kimokcheon.github.io//styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Yuchuan&#39;s Blog
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://kimokcheon.github.io/post/about-me" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1695778991029" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    计算机体系结构
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2023-06-28 ·
                    </time>
                    
                </div>
                <div class="post-content">
                    <h1 id="第1章-引言">第1章 引言</h1>
<h2 id="11-计算机体系结构的研究内容">1.1 计算机体系结构的研究内容</h2>
<ol>
<li><strong>按下键盘到幻灯片翻页</strong>：键盘传信号到南桥，南桥保存键盘编号并发出外部中断，中断信号附在指令上进入ROB，当执行到该条指令时清空流水线，然后设置系统状态为核心态（RISCV就是修改sstatus）、保存异常时PC值（RISCV就是sepc）、例外原因（RISCV就是scause）。然后置PC为中断服务程序入口，跳转过去。跳转之后保存上下文，向CPU读例外原因（中断），然后向南桥读中断原因（敲空格键），之后找到一个PowerPoint进程正处于阻塞态，等待空格键，于是唤醒这个进程。随后PowerPoint准备下一张幻灯片内容，再给一个中断，把待显示内容传给显存，并让GPU刷新屏幕。</li>
<li><strong>如果翻页过程中卡顿，可能是什么原因？</strong>
<ul>
<li>打开进程过多。</li>
<li>CPU主频低（可能性较小，因为翻页并不需要太高的性能）。</li>
<li>矢量图较多，GPU性能低。</li>
<li>要显示的数据量比较大，内存带宽不足。</li>
</ul>
</li>
<li><strong>通用计算机系统的结构层次</strong>：<pre><code>--------------------------
|        应用程序         |
--------------------------
           API
--------------------------
|        操作系统         |
--------------------------
           ISA
--------------------------
|        硬件系统         |
--------------------------
         工艺模型
--------------------------
|         晶体管         |
--------------------------
</code></pre>
</li>
<li><strong>冯诺依曼结构</strong>：
<ul>
<li>构成：控制器、运算器、存储器、输入设备、输出设备。</li>
<li>指令和数据存储在存储器中，CPU从内存中取出指令和数据进行运算，并把运算结果存在内存中。</li>
<li><strong>本质特征：存储程序和指令驱动执行</strong></li>
</ul>
</li>
</ol>
<h2 id="12-衡量计算机的指标">1.2 衡量计算机的指标</h2>
<p><strong>性能、价格和功耗</strong>是衡量一台计算机好坏的三个重要指标。</p>
<h3 id="121-性能">1.2.1 性能</h3>
<p>影响性能的因素：</p>
<ul>
<li><strong>指令数</strong>：算法、编译器、指令系统设计</li>
<li><strong>CPI</strong>：指令系统设计、微结构</li>
<li><strong>每周期用时（主频）</strong>：微结构、电路设计和工艺</li>
</ul>
<h3 id="122-价格">1.2.2 价格</h3>
<ol>
<li>性价比：
<ul>
<li>高性能计算机：首要考虑性能</li>
<li>嵌入式应用：为追求低功耗低成本，可以牺牲一部分性能</li>
<li>介于二者之间：性价比</li>
</ul>
</li>
<li>影响成本的因素：<strong>芯片成本</strong>为主，含<strong>一次性成本</strong>（研发成本）和<strong>制造成本</strong>（生产量上来了，生产技艺就会改良，次品率少了，成本也会下降）。</li>
</ol>
<h3 id="123-功耗">1.2.3 功耗</h3>
<ul>
<li><strong>动态功耗</strong>
<ul>
<li><strong>开关功耗</strong>：电压变换（0/1），电容充放电</li>
<li><strong>短路功耗</strong>：电压翻转过程中，N管和P管暂时性同时打开，产生短暂的短路</li>
</ul>
</li>
<li><strong>静态功耗</strong>
<ul>
<li><strong>漏电功耗</strong>：源极、栅极、漏极、衬底之间都有可能发生漏电，产生漏电功耗</li>
</ul>
</li>
</ul>
<p>降低电容、电压，降低频率，改进工艺；结构和逻辑设计上降低翻转率等。</p>
<h2 id="13-计算机体系结构的发展">1.3 计算机体系结构的发展</h2>
<ol>
<li>计算机体系结构发展的<strong>动力</strong>：
<ul>
<li><strong>工艺技术的发展</strong>：半导体工艺技术和计算机体系结构技术互为动力；摩尔定律在逐渐失效，工艺技术对体系结构的影响在降低。</li>
<li><strong>应用需求的提高</strong>：网络计算、游戏等；将成为首要动力。</li>
</ul>
</li>
<li><strong>摩尔定律</strong>：
<ul>
<li>常规表述：晶体管数目每18-24个月翻一番。</li>
<li>不是客观规律，是主观经验。</li>
</ul>
</li>
<li>摩尔电路与计算机结构进步：
<ul>
<li>第一代：电子管计算机</li>
<li>第二代：晶体管计算机</li>
<li>第三代：中小规模IC计算机</li>
<li>第四代：大规模IC计算机</li>
</ul>
</li>
<li>“墙”：
<ul>
<li>存储墙：CPU和存储器速度的剪刀差</li>
<li>功耗墙：高主频设计带来过高的功耗</li>
<li>成本墙：越来越贵</li>
<li>复杂度墙：芯片设计复杂度越来越高，难以设计</li>
<li>...</li>
</ul>
</li>
</ol>
<h2 id="14-体系结构设计的基本原则">1.4 体系结构设计的基本原则</h2>
<p><strong>平衡性、局部性、并行性、虚拟化</strong>。</p>
<ul>
<li><strong>平衡性</strong>：<strong>统筹兼顾</strong>。木桶原理，各结构应平衡设计，避免某个结构性能过低制约整个系统。例如CPU的计算性能和访存带宽的平衡；Amdahl定律。</li>
<li><strong>局部性</strong>：<strong>重点突出</strong>。利用局部性进行系统性能优化；RISC的二八定律；访存局部性（时间、空间）产生Cache、TLB、预取等结构和设计。</li>
<li><strong>并行性</strong>：开发各个层次的并行性。</li>
<li><strong>虚拟化</strong>：“用起来是这样，实际上是那样”。比如虚拟内存、多线程、虚拟机、Cache的提出、Cache一致性协议等。</li>
</ul>
<h1 id="第2章-指令系统">第2章 指令系统</h1>
<h2 id="21-指令系统简介">2.1 指令系统简介</h2>
<p>是软硬件的界面，不仅与指令功能有关，还涉及到运行环境（Cache管理、存储管理、安全管理、异常和中断处理……）。</p>
<h2 id="22-指令系统设计原则">2.2 指令系统设计原则</h2>
<ol>
<li>指令系统设计的<strong>基本原则</strong>：
<ul>
<li><strong>兼容性</strong>：关键特性，对软件向前兼容，支持过时指令。</li>
<li><strong>通用性</strong>：各种应用的需求，例如视频解码相关指令等。</li>
<li><strong>高效性</strong>：便于CPU硬件结构的设计优化，提升性能。</li>
<li><strong>安全性</strong>：考虑不同的安全要求，提供保护等。</li>
</ul>
</li>
<li>指令系统设计的<strong>影响因素</strong>：
<ul>
<li><strong>工艺技术</strong>：片内可集成晶体管数目增多，功能集成度提高，可支持更多功能。</li>
<li><strong>计算机体系结构</strong>：直接影响；指令系统兼容性与体系结构发展之间的矛盾。</li>
<li><strong>操作系统</strong>：异常和中断、安全等级、多进程和虚拟内存的支持等（例如专用控制寄存器操作）。</li>
<li><strong>编译技术</strong>：使编译器有效地调度指令，增加编译灵活性等。</li>
<li><strong>应用程序</strong>：算法支持、应用需求。</li>
</ul>
</li>
</ol>
<h2 id="23-指令系统发展历程">2.3 指令系统发展历程</h2>
<h3 id="231-指令内容的演变">2.3.1 指令内容的演变</h3>
<ol>
<li>根据<strong>指令长度</strong>的不同，可分为<strong>CISC（复杂指令系统）、RISC（精简指令系统）和VLIW（超长指令字）</strong>。</li>
<li>CISC变长；RISC定长；VLIW本质上是多条同时执行的指令的组合。</li>
</ol>
<h3 id="232-存储管理的演变">2.3.2 存储管理的演变</h3>
<ol>
<li>段式、页式、段页式。</li>
<li>三种存储管理方式的地址转换过程。</li>
</ol>
<h3 id="233-运行级别的演变">2.3.3 运行级别的演变</h3>
<p>无管理-&gt;增加保护模式（权限）-&gt;增加调试模式-&gt;增加客户模式（又称虚拟化支持）</p>
<p>不同运行级别下可访问的资源不同，一般是包含关系。</p>
<h2 id="24-指令系统的组成">2.4 指令系统的组成</h2>
<p>操作码和操作数。</p>
<h3 id="241-地址空间">2.4.1 地址空间</h3>
<ol>
<li>处理器可访问的地址空间包括<strong>立即数</strong>、<strong>寄存器空间</strong>和<strong>系统内存空间</strong>。
<ul>
<li>寄存器空间：通用寄存器、专用寄存器、控制状态寄存器；</li>
<li>系统内存空间：内存空间、IO空间。</li>
</ul>
</li>
<li>使用相同的load/store指令访问内存空间和IO空间。</li>
<li>处理器对IO空间的访问不能经过Cache，因此需要有标记，指明访存是否经过Cache。</li>
<li>根据指令使用数据的方式，指令系统可分为<strong>堆栈型、累加器型、寄存器-存储器型、寄存器-寄存器型</strong>。
<ul>
<li><strong>堆栈型</strong>：操作数都在栈顶，运算结果默认存回栈顶，通过PUSH和POP改变栈的内容。</li>
<li><strong>累加器型</strong>：一个操作数隐含在累加器中，另一个操作数由指令指定，可以是内存中的值，也可以是寄存器中的值。</li>
<li><strong>寄存器-存储器型</strong>：跟累加器型比较像，但是没有隐含操作数，操作数为寄存器和内存单元，须显式指定。</li>
<li><strong>寄存器-寄存器型</strong>：除了访存指令之外，其他指令只能操作寄存器。</li>
</ul>
</li>
<li>早期多用<strong>堆栈型</strong>和<strong>累加器型</strong>，主要目的是<strong>降低硬件实现的复杂度</strong>；现在多用<strong>寄存器-寄存器型</strong>，目的在于<strong>提高访存速度</strong>以及充分利用<strong>局部性原理</strong>。另外，寄存器-寄存器型的优势是<strong>容易判断相关</strong>。</li>
</ol>
<h3 id="242-操作数">2.4.2 操作数</h3>
<ol>
<li><strong>大尾端和小尾端</strong>：小尾端起始地址在一个字的最后一个字节，大尾端反之。</li>
<li><strong>寻址方式</strong>：寄存器寻址、立即数寻址、偏移量寻址、寄存器间接寻址等。</li>
</ol>
<h3 id="243-指令操作和编码">2.4.3 指令操作和编码</h3>
<ol>
<li>从<strong>功能</strong>上看，可分为四大类：<strong>运算指令、访存指令、转移指令、特殊指令</strong>。
<ul>
<li><strong>运算指令</strong>：加减乘除、移位运算、逻辑运算等；</li>
<li><strong>访存指令</strong>：load/store，取数长度、寻址方式等；</li>
<li><strong>转移指令</strong>：相对/绝对、直接/间接、条件/无条件；</li>
<li><strong>特殊指令</strong>：TLB管理、Cache管理、异常管理、安全管理等。</li>
</ul>
</li>
<li>最常用的指令是一些简单指令，把这些加快可有效提升性能，其它的慢一点没关系（局部性原理）。“常用的做得快，少用的只要对。”</li>
<li>转移指令确定转移条件的方式：<strong>判断条件码</strong>和<strong>比较寄存器的值</strong>。
<ul>
<li><strong>判断条件码</strong>：采用运算指令计算条件，置条件码，条件指令使用条件码判断是否转移。</li>
<li><strong>比较寄存器的值</strong>：转移指令直接比较寄存器判断是否转移。</li>
</ul>
</li>
</ol>
<h2 id="25-risc指令集比较">2.5 RISC指令集比较</h2>
<p>比较的RISC指令集：MIPS、PA-RISC、PowerPC、SPARC v9、LoongArch。</p>
<p>RISCV也是常用的RISC指令集。</p>
<ul>
<li><strong>指令格式</strong>：主要组成元素基本相同，只是摆放位置存在差别。</li>
<li><strong>寻址方式</strong>：都支持四种基本的寻址方式——寄存器寻址、立即数寻址、偏移量寻址、变址寻址。PA-RISC和PowerPC支持的寻址方式更多一些。</li>
<li><strong>指令功能</strong>：区别较大。</li>
</ul>
<h3 id="251-不同指令的特色">2.5.1 不同指令的特色</h3>
<ul>
<li><strong>MIPS</strong>：<strong>非对齐访存</strong>。LWL读取访存地址所在的字并将访存地址到该字中最低位的字节拼接到目标寄存器的高位；LWR读取访存地址所在的字并将访存地址到该字中最高位的字节拼接到目标寄存器的低位。依尾端而不同：</li>
</ul>
<center><img src="/assets/images/体系结构/2-1.png" alt="2-1" style="zoom: 50%;" /></center>
<ul>
<li><strong>SPARC</strong>：<strong>寄存器窗口</strong>。</li>
<li><strong>PowerPC</strong>：<strong>Link和Count寄存器</strong>。</li>
<li><strong>PA-RISC</strong>：<strong>Nullification</strong>。</li>
</ul>
<h2 id="26-c语言的机器表示">2.6 C语言的机器表示</h2>
<ol>
<li><strong>过程调用（函数调用）</strong>：bl和jr指令。用栈或寄存器保存参数，保存和恢复现场。</li>
<li>哪些情况下需要保留和恢复现场？
<ul>
<li><strong>函数调用</strong>：sp和ra寄存器需要保存，简单的调用不需要保存。</li>
<li><strong>线程切换</strong>：几乎全部通用寄存器（除了部分操作系统专用的）。</li>
<li><strong>进程切换</strong>：几乎全部通用寄存器（除了部分操作系统专用的），其它现场。</li>
<li><strong>例外处理</strong>：例外处理要用的寄存器要保留。</li>
<li><strong>虚拟机切换</strong>：所有通用寄存器，部分控制操作系统用的寄存器。</li>
</ul>
</li>
</ol>
<h1 id="第3章-特权指令系统">第3章 特权指令系统</h1>
<h2 id="31-特权指令系统简介">3.1 特权指令系统简介</h2>
<ol>
<li>用户程序能看到的：<strong>用户态指令系统结构、操作系统提供的系统调用</strong>（合称<strong>ABI</strong>）。</li>
<li>操作系统能看到的：<strong>用户态指令系统结构、特权态指令系统结构</strong>。</li>
<li><strong>编译器编译不出特权态指令，其为操作系统专用</strong>。</li>
<li>特权态指令作用：
<ul>
<li><strong>定义和切换运行模式</strong></li>
<li><strong>异常与中断处理</strong></li>
<li><strong>虚拟存储管理</strong></li>
</ul>
</li>
<li>用户态可见的寄存器：
<ul>
<li>通用寄存器（含浮点寄存器）</li>
<li>部分控制状态寄存器（如X86的EFLAG，LoongArch的FCSR）</li>
</ul>
</li>
</ol>
<h2 id="32-异常与中断">3.2 异常与中断</h2>
<h3 id="321-异常分类">3.2.1 异常分类</h3>
<ol>
<li>异常定义：使软件<strong>从正常执行流中脱离</strong>的事件。</li>
<li>分类：根据来源，分为<strong>外部事件、指令执行中的错误、数据完整性问题、地址转换异常、系统调用和陷入、需要软件修正的运算</strong>。
<ul>
<li><strong>外部事件</strong>：来自CPU流水线外部的事件，也称中断。例如键盘输入。</li>
<li><strong>指令执行中的错误</strong>：指令未定义、用户态无权访问的指令或地址、除零异常、地址不对齐、整数运算溢出等。</li>
<li><strong>数据完整性问题</strong>：ECC（检二纠一）或奇偶校验错误，来源于存储器软错误。</li>
<li><strong>地址转换异常</strong>：虚实地址转换时，没有有效的TLB项。</li>
<li><strong>系统调用和陷入</strong></li>
<li><strong>需要软件修正的运算</strong>：通常来源于浮点运算指令，硬件实现过于复杂而不支持，交给软件。</li>
</ul>
</li>
</ol>
<h3 id="322-异常处理">3.2.2 异常处理</h3>
<ol>
<li><strong>精确异常</strong>：发生异常时，被异常打断的指令前的所有指令都已经执行完，该指令之后的所有指令都像没执行一样。</li>
<li>异常处理流程：<strong>异常处理准备、确定异常来源、保存执行状态、执行异常处理、恢复执行状态并返回</strong>。
<ul>
<li><strong>异常处理准备</strong>：① <strong>记录EPTR</strong>，LoongArch将EPTR存储到CSR.ERA寄存器（RISCV：sepc寄存器）；② <strong>调整权限等级</strong>，LoongArch将CSR.PLV置0以进入最高权限等级；③ <strong>屏蔽所有中断</strong>，LoongArch将CSR.CRMD的IE域置0。④ 保存异常发生现场的部分信息，例如将CSR.CRMD的PLV和IE域记录到CSR.PRMD的PPLV和LIE域中，供异常返回时使用。</li>
<li><strong>确定异常来源</strong>：主要有两种方式：① 发生异常时进入同一个异常处理程序，然后查询异常编号，进入相应的处理函数入口；② 发生异常时根据异常来源进入不同的异常处理程序，这样就自动知晓异常来源。</li>
<li><strong>保存执行状态</strong>：将通用寄存器和部分CSR压栈。</li>
<li><strong>处理异常</strong></li>
<li><strong>恢复执行状态</strong>：从栈中取出通用寄存器和部分CSR。</li>
<li><strong>异常处理返回</strong>：<u>同时</u>完成权限等级的切换和返回地址恢复。LoongArch中是ertn指令，x86是iret指令。</li>
</ul>
</li>
<li><strong>异常嵌套</strong>：将异常分为多个优先级，更高优先级的异常可以抢占处理。</li>
</ol>
<h3 id="323-中断">3.2.3 中断</h3>
<ol>
<li>有两类异常非常容易出现，<strong>地址转换异常</strong>（访问地址不在TLB中）和<strong>中断</strong>（外部事件想要获得CPU）。</li>
<li><strong>中断传递机制</strong>：从中断源传递到CPU的方式，主要有<strong>中断线和消息中断</strong>。
<ul>
<li><strong>中断线</strong>：中断源不多时，直接从中断源连线到处理器引脚（LoongArch，电平中断）；也可以先把连线汇总到中断控制器（这时采用边沿中断），然后转发汇总到（可能是不同的）CPU。但是这样会占用CPU引脚，因此一般只在SoC上使用。</li>
<li><strong>消息中断</strong>：消息中断以<strong>数据(消息)</strong> 的方式在<strong>系统总线</strong>上传递。发中断就是向指定的地址写一个指定的数。</li>
</ul>
</li>
<li><strong>向量化中断</strong>：嵌入式CPU对中断处理实时性要求较高，因此为每个中断设置独立的入口，进入后直接处理。这样就省去了进入中断处理程序后识别中断源的开销，加速处理。</li>
<li>中断使能控制位的原子修改：修改CSR.CRMD中断使能位时，操作必须是原子的，不然也可能被中断打断。方式有：<strong>禁用中断、添加专门的位原子修改指令、不允许中断处理程序修改SR、使用通用的方法保证程序段的原子性</strong>等。LoongArch中添加了csrxchg指令，专门用来原子地修改中断使能位。</li>
</ol>
<h3 id="33-存储管理">3.3 存储管理</h3>
<p>ipad</p>
<h1 id="第4章-软硬件协同">第4章 软硬件协同</h1>
<h2 id="41-abi">4.1 ABI</h2>
<ol>
<li>ABI定义了应用程序二进制代码中相关数据结构和函数模块的格式及其访问方式，使得不同的二进制模块之间的交互成为可能。</li>
<li>内容：
<ul>
<li><strong>数据表示和对齐要求</strong></li>
<li><strong>寄存器使用约定</strong></li>
<li><strong>函数调用约定</strong></li>
<li><strong>栈布局</strong></li>
<li><strong>目标文件和可执行文件格式</strong></li>
</ul>
</li>
<li>函数调用规范</li>
<li>进程虚拟地址空间布局</li>
<li>栈帧布局</li>
</ol>
<h2 id="42-六种常见的上下文切换场景">4.2 六种常见的上下文切换场景</h2>
<ul>
<li><strong>函数调用</strong></li>
<li><strong>异常和中断</strong></li>
<li><strong>系统调用</strong></li>
<li><strong>进程切换</strong></li>
<li><strong>线程切换</strong></li>
<li><strong>虚拟机</strong>：虚拟机无法独立处理内部的上下文切换时，会退出虚拟机的状态，借助宿主机的虚拟化管理软件来完成任务。虚拟机和宿主机之间的切换需要保存和恢复所有可能被修改的虚拟机相关状态信息。</li>
</ul>
<h2 id="43-同步机制">4.3 同步机制</h2>
<ol>
<li>自旋锁（自旋等待）、互斥锁（阻塞与唤醒）</li>
<li>读-改-写指令、LL/SC指令</li>
<li>事务内存：非阻塞的同步机制，核心思想是通过尝试性地执行事务代码，在程序执行过程中动态检测事务间的冲突，并根据冲突检测结果提交或取消事务。</li>
</ol>
<h1 id="第5章-计算机组成原理和结构">第5章 计算机组成原理和结构</h1>
<h2 id="51-冯诺依曼结构">5.1 冯诺依曼结构</h2>
<ol>
<li>组成：
<ul>
<li>逻辑上：运算器、控制器、存储器、输入设备、输出设备。五大部分</li>
<li>物理上：CPU（运算器、控制器、Cache）、内存、IO设备。三大部分</li>
</ul>
</li>
<li>存储程序和指令驱动执行。</li>
</ol>
<h2 id="52-计算机的组成部件">5.2 计算机的组成部件</h2>
<h3 id="521-运算器">5.2.1 运算器</h3>
<ol>
<li>运算器包括：ALU（算术和逻辑运算部件）、移位部件、FPU（浮点运算部件）、向量运算部件、寄存器等。</li>
<li>运算器支持的<strong>运算类型</strong>经历了<strong>由简单到复杂</strong>的过程。</li>
<li>随着晶体管集成度的不断提升，处理器中所集成的<strong>运算器的数量</strong>也在持续增加。</li>
</ol>
<h3 id="522-控制器">5.2.2 控制器</h3>
<ol>
<li>含程序计数器和指令寄存器。</li>
<li>指令通过译码产生控制信号，这些控制信号可以由硬连线产生，可以由微程序产生，也可以由两者结合产生。</li>
<li>常采用指令流水线、超标量、转移预测、乱序执行，预取及高速缓存等技术来提高指令吞吐率。</li>
<li>体系结构研究的一个永恒的主题就是<strong>加速指令执行周期，从而提高计算机运行程序的效率</strong>。</li>
<li><strong>乱序执行</strong>：缓解由于指令相关引起的阻塞。
<ul>
<li><strong>译码后，执行指令前</strong>，判断操作数是否准备好。若已准备好，直接执行；否则就进入<strong>保留站</strong>（又称<strong>发射队列</strong>）等待。</li>
<li><strong>乱序执行，但有序结束</strong>。指令执行前，按顺序进入<strong>ROB</strong>；然后乱序执行，将结果写入<strong>重命名寄存器</strong>；指令执行后，按照在ROB中的顺序，将重命名寄存器中的结果逐条提交到目标寄存器或存储器中。</li>
<li>重命名寄存器可有效地避免不同运算访问同一个结构寄存器所带来的并行化瓶颈。</li>
</ul>
</li>
<li><strong>超标量技术</strong>：
<ul>
<li>超标量技术使得寄存器、保留站、ROB的端口数，以及功能部件的个数都要增加。</li>
<li>超标量技术还会带来同一拍中多条指令间的相关。</li>
</ul>
</li>
<li><strong>转移预测</strong>：
<ul>
<li>根据<strong>转移历史</strong>，在转移指令的<strong>取指或译码</strong>阶段预测转移方向和地址。</li>
<li>转移指令的<strong>执行</strong>阶段需要判定预测结果是否正确。若错误，则需要<strong>取消</strong>流水线中的后续指令。</li>
<li>常见的技术有<strong>转移历史表BHT、分支目标缓冲BTB、返回地址栈RAS</strong>等。</li>
</ul>
</li>
</ol>
<h3 id="523-存储器">5.2.3 存储器</h3>
<ol>
<li>三个层次：<strong>Cache、主存储器（内存）、辅助存储器</strong>。
<ul>
<li>Cache：SRAM（比DRAM容量小，但速度快）</li>
<li>内存：DRAM</li>
<li>辅助存储器：磁盘、SSD</li>
</ul>
</li>
<li>少量<strong>ROM</strong>（只读存储器），存放<strong>引导程序</strong>和<strong>BIOS</strong>。</li>
<li><strong>MMU</strong>负责虚实地址转换。</li>
<li>存储介质：
<ul>
<li><strong>SRAM</strong>：易失、快、贵</li>
<li><strong>DRAM</strong>：易失、慢、便宜</li>
<li><strong>闪存</strong>：非易失、快、贵（U盘、SSD，在变多变便宜）</li>
<li><strong>磁性存储介质</strong>：磁盘、硬盘、磁带</li>
</ul>
</li>
<li>Cache：
<ul>
<li>缓解内存速度与处理器速度的剪刀差。</li>
<li>利用访存的空间局部性和时间局部性。</li>
<li>现代处理器普遍在片内集成多级Cache。</li>
<li>AMAT = HitTime + MissRate × MissPenalty</li>
</ul>
</li>
<li>内存：SDRAM实现
<ul>
<li>基本单元：由<strong>MOS管（打开/关闭本单元）和电容（存储逻辑值）</strong> 组成。</li>
<li>读：位线预充到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msub><mi>V</mi><mrow><mi>c</mi><mi>c</mi></mrow></msub><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{V_{cc}}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.233431em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884309999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.22222em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，字线打开MOS管，感应放大器放大数据（此时C中的电容被破坏）；写：字线上提供更大的电流，重置感应放大器和位线的值。</li>
<li>电容会漏电，<strong>周期刷新</strong>，通过读操作完成。</li>
<li>读写速度影响因素：<strong>行缓冲局部性和Bank级并行度</strong>
<ul>
<li><strong>行缓冲局部性</strong>：读操作后，数据被存到<strong>感应放大器</strong>（即<strong>行缓冲</strong>，读写延迟低一些）中，电容被破坏。<strong>Close Page</strong>：每次读写完之后都从行缓冲写回存储体；<strong>Open Page</strong>：先不写回，下次读写时，如果命中直接从行缓冲中取出，如果不命中就先写回再到新地址访存。<strong>局部性</strong>好就用Open Page，不好就用Close Page。</li>
<li><strong>Bank级并行度</strong>：不同Bank可以并行访问。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="524-io设备">5.2.4 IO设备</h3>
<ol>
<li>GPU：
<ul>
<li>显示过程：CPU把要显示的数据放到内存，通知GPU通过DMA方式读取这些数据，GPU解析和运算后，把结果写到显存中，再由显示控制器读取显存数据并输出显示。</li>
<li>集显的CPU和GPU距离近，<strong>内存一致性维护开销和数据传输延迟会大幅降低</strong>。但是系统内存要承担显存的作用，<strong>访存压力大幅增加</strong>。</li>
</ul>
</li>
<li>硬盘：
<ul>
<li><strong>性能指标</strong>：延迟和带宽。</li>
<li><strong>访问时间</strong>：寻道时间（找磁道）、旋转时间（找扇区）和传输时间（传数据）。</li>
</ul>
</li>
<li>闪存：U盘、SD卡、SSD固态硬盘都是闪存。</li>
</ol>
<h2 id="53-计算机硬件结构演进">5.3 计算机硬件结构演进</h2>
<ul>
<li>CPU</li>
<li>GPU</li>
<li>北桥：离CPU最近，控制<strong>显卡、内存与CPU之间</strong>的数据交换。向上连接处理器，向下连接南桥。</li>
<li>南桥：<strong>硬盘、键盘以及带宽要求低的IO接口与内存、CPU之间</strong>的数据交换。</li>
</ul>
<h3 id="531-cpu-gpu-北桥-南桥四片结构">5.3.1 CPU-GPU-北桥-南桥四片结构</h3>
<ol>
<li>CPU、南桥、北桥在主板上，GPU以显卡的形式插在主板插槽上。</li>
<li>CPU通过系统总线连接北桥，GPU以显卡的形式连接北桥。北桥通过南北桥总线连接南桥。</li>
<li>内存控制器集成在北桥中，GPU以显卡的形式连接北桥；硬盘接口、USB接口、网络接口、音频接口、键鼠接口（这都是低速IO）在南桥中。</li>
<li>北桥还会提供扩展接口，连接其它功能卡。<strong>北桥是系统连接的枢纽。</strong></li>
</ol>
<h3 id="532-cpu-北桥-南桥三片结构">5.3.2 CPU-北桥-南桥三片结构</h3>
<ol>
<li>与四片结构的最大区别：三片结构的GPU被集成到北桥中。</li>
<li>CPU通过系统总线连接北桥，北桥通过南北桥总线连接南桥。</li>
<li>内存控制器、显示功能、高速IO（如PCIE等）集成在北桥中；硬盘接口、USB接口、网络接口、音频接口、键鼠接口（这都是低速IO）在南桥中。</li>
</ol>
<h3 id="533-cpu-弱北桥-南桥三片结构">5.3.3 CPU-弱北桥-南桥三片结构</h3>
<ol>
<li>随CPU性能提高，访存速率对整体性能制约越来越大（存储墙问题），访存速率要求超过CPU与北桥之间的系统总线带宽。因此将内存控制器从北桥转移到CPU中。</li>
<li>北桥不再有内存控制器，剩下显示功能、高速IO。</li>
</ol>
<h3 id="534-cpu-南桥两片结构">5.3.4 CPU-南桥两片结构</h3>
<ol>
<li>GPU越来越猛，也从北桥脱离进入CPU。北桥越来越弱，直接和南桥合并（还叫南桥）。</li>
<li>CPU集成处理器核、内存控制器和GPU，通过系统总线和南桥相连。</li>
<li>南桥包含硬盘、USB、网络控制器，以及PCIE/PCI、LPC等总线接口。</li>
<li>GPU和CPU在一块，会带来访存冲突。一般GPU优先级高一些，一定程度上会影响CPU性能。</li>
</ol>
<h3 id="535-soc单片结构">5.3.5 SoC单片结构</h3>
<ol>
<li>单片计算机系统，集成了处理器、内存控制器、GPU以及硬盘USB、网络等IO接口。</li>
<li>小型化、低功耗。面向中低端和嵌入式。</li>
</ol>
<h2 id="54-处理器和io设备通信">5.4 处理器和IO设备通信</h2>
<ol>
<li>IO设备由<strong>设备控制器</strong>控制。设备控制器提供一组<strong>IO寄存器</strong>接口。寄存器内容改变会引起设备控制器执行一系列复杂的动作。</li>
<li><strong>处理器通过向IO寄存器写入命令字（即修改IO寄存器的值）来控制IO设备</strong>。</li>
</ol>
<h3 id="541-io寄存器寻址">5.4.1 IO寄存器寻址</h3>
<p>两种方式：<strong>内存映射IO和特殊IO指令</strong>。</p>
<h3 id="542-处理器和io设备的同步">5.4.2 处理器和IO设备的同步</h3>
<ol>
<li>两种方式：<strong>查询和中断</strong>。</li>
<li><strong>查询</strong>：又称<strong>轮询</strong>，处理器向IO设备发出访问请求后，就不断读取IO设备的状态寄存器，直到满足访问条件。大多数IO设备比较慢，因此查询容易造成<strong>性能浪费</strong>。</li>
<li><strong>中断</strong>：处理器让设备开始干活后，就转而做其他事。设备完成任务后，产生中断信号中断处理器的执行。中断的一般过程：
<ul>
<li>中断源产生中断信号，到中断控制器</li>
<li>中断控制器产生中断请求，到CPU</li>
<li>CPU产生中断响应，读取中断类型码</li>
<li>CPU根据中断类型码执行对应的中断服务程序</li>
<li>CPU从中断服务程序返回，执行结束</li>
</ul>
</li>
</ol>
<h3 id="542-存储器和io设备的通信">5.4.2 存储器和IO设备的通信</h3>
<ol>
<li>两种方式：<strong>PIO和DMA</strong>。</li>
<li>CPU访问IO设备都是<strong>Uncache访问</strong>。</li>
<li><strong>PIO</strong>：<strong>经由CPU，以通用寄存器做中介</strong>。存储器向IO设备搬运数据时，处理器先把数据从存储器搬到通用寄存器中，然后再从通用寄存器写到IO设备中，反之则反。
<ul>
<li>PIO方式访问延迟大，且IO访问之间需要严格的顺序关系。</li>
<li>PIO有两种同步方式：查询和中断。</li>
<li>一般用于<strong>低速IO设备</strong>的工作，如键盘、鼠标。</li>
</ul>
</li>
<li><strong>DMA</strong>：在存储器和IO设备之间专门开辟通道，由DMA控制器控制传输。
<ul>
<li>一般过程为：① 处理器为DMA请求分配一段地址空间，并为DMA控制器配置参数；② DMA控制器开始传输，CPU转而做其他事；③ DMA控制器完成后向CPU发中断，通知执行情况（完成or出错，出错还得有错误信息）；④ 处理器完成本次DMA请求。</li>
<li>一般用于<strong>高速IO设备</strong>的工作，如网卡收发包、硬盘传输等。</li>
</ul>
</li>
</ol>
<h1 id="第6章-计算机总线接口技术">第6章 计算机总线接口技术</h1>
<h2 id="61-总线概述">6.1 总线概述</h2>
<ol>
<li>本质作用：<strong>完成数据交换</strong>。</li>
<li>层次：
<ul>
<li><strong>机械层</strong>：接口的外形尺寸等。</li>
<li><strong>电气层</strong>：信号描述、电源电压、电平标准、信号质量等。</li>
<li><strong>协议层</strong>：信号时序、握手规范、命令格式、出错处理等。</li>
<li><strong>架构层</strong>：硬件模型、软件架构等。</li>
</ul>
</li>
</ol>
<h2 id="62-总线分类">6.2 总线分类（※）</h2>
<ol>
<li>按数据传送方向：
<ul>
<li>单向总线：VGA</li>
<li>双向总线
<ul>
<li>半双工：USB 2.0</li>
<li>全双工：UART</li>
</ul>
</li>
</ul>
</li>
<li>按总线使用的信号类型（数据组织方式）：
<ul>
<li>并行总线：PCI</li>
<li>串行总线：PCIe、SATA、HT</li>
</ul>
</li>
<li>按数据握手方式：
<ul>
<li>无握手：DVI、APB</li>
<li>Vlid-Ready：PCI、AXI</li>
<li>Credit：PCIe、HT</li>
</ul>
</li>
<li>按连接方式：
<ul>
<li>共享信号（通过仲裁决定占有总线）：PCI</li>
<li>点对点（专用的交换节点）：PCIe</li>
</ul>
</li>
<li>按时钟实现方式：
<ul>
<li>全局时钟（时钟源到各部件路径等长）：PCI</li>
<li>源同步：
<ul>
<li>时钟随数据一起发送，二者路径等长：HT</li>
<li>时钟嵌入到数据中发送：PCIe</li>
</ul>
</li>
</ul>
</li>
<li><strong>按总线所处的位置</strong>：
<ul>
<li><strong>片上总线</strong>：AXI、AHB、ASB、APB等</li>
<li><strong>内存总线</strong>：内存控制器和内存条之间的接口</li>
<li><strong>系统总线</strong>：QPI、FSB、HT</li>
<li><strong>设备总线</strong>：PCI、PCIe</li>
</ul>
</li>
</ol>
<h2 id="63-片上总线">6.3 片上总线</h2>
<ol>
<li>嵌入式SoC芯片上的功能模块称为<strong>IP</strong>。IP间通过片上总线互连。</li>
<li>主流片上总线是ARM公司的AMBA系列总线，包括AXI、AHB、ASB、APB等总线。</li>
<li>片上总线的特点（与片外实现相比）：<strong>高并行性</strong>（最大特点）；引线资源丰富；全局时钟相对容易实现；不需要复杂的物理层转换；不使用三态信号。</li>
<li>片上总线的性能：频率（能否加流水级）、数据位宽、带宽利用率（总线事务中数据传输时间占总时间的比例）。</li>
<li>AXI特点：支持不对齐访问；读写分离。</li>
</ol>
<h2 id="64-内存总线">6.4 内存总线</h2>
<ol>
<li>内存总线规范由<strong>JEDEC</strong>组织制定，包含总线的三个层级：机械层、电气层、协议层。</li>
<li>内存总线<strong>信号分类</strong>：
<ul>
<li><strong>时钟信号</strong></li>
<li><strong>地址命令信号</strong></li>
<li><strong>数据及数据采样信号</strong></li>
</ul>
</li>
<li>对DRAM的寻址是按照<strong>bank地址、行地址和列地址</strong>来进行的。</li>
<li>对内存总线的控制是通过<strong>内存控制器</strong>实现的。内存控制器负责管理内存条的初始化、读写、低功耗控制等操作。</li>
</ol>
<h2 id="65-系统总线">6.5 系统总线</h2>
<ol>
<li>所处的位置：处理器与桥片之间、多处理器之间。</li>
<li>串行总线、点对点传输、全双工传输。</li>
<li>HT的流控机制、虚通道。</li>
</ol>
<h2 id="66-设备总线io总线">6.6 设备总线（IO总线）</h2>
<ol>
<li>PCI和PCIe。</li>
<li>PCIe兼容PCI软件架构，基本取代PCI。</li>
</ol>
<h1 id="第10章-并行编程基础">第10章  并行编程基础</h1>
<ol>
<li>计算机体系结构是描述计算机<strong>各组成部分</strong>及其<strong>相互关系</strong>的一组规则和方法，是程序员所看到的计算机属性。</li>
<li>计算机体系结构主要研究内容包括<strong>指令系统结构(ISA)</strong> 和 <strong>计算机组织结构(CO)</strong>。</li>
<li><strong>微体系结构</strong>是<strong>微处理器</strong>的组织结构，<strong>并行体系结构</strong>是<strong>并行计算机</strong>的组织结构。</li>
<li>冯诺依曼结构的<strong>存储程序</strong>和<strong>指令驱动执行</strong>是现代计算机体系结构的基础。</li>
</ol>
<h2 id="101-程序的并行行为">10.1 程序的并行行为</h2>
<p>程序的并行行为包括：<strong>指令级并行、数据级并行、任务级并行</strong>。</p>
<h3 id="1011-指令级并行">10.1.1 指令级并行</h3>
<ol>
<li>只有<strong>RAW数据相关</strong> 和 <strong>控制相关</strong>真正制约指令级并行执行。</li>
<li>实现方式：<strong>微结构设计技术</strong>。例如<strong>指令流水线、多发射、动态调度、寄存器重命名、转移猜测</strong>等。</li>
<li>喂饱“饥饿”的运算器：<strong>转移猜测</strong>（提供足够的<strong>指令</strong>）、<strong>存储管理</strong>（提供足够的<strong>数据</strong>）。</li>
</ol>
<h3 id="1012-数据级并行">10.1.2 数据级并行</h3>
<ol>
<li>数据级并行是指<strong>对集合或者数组中的元素同时执行相同的操作</strong>。</li>
<li>实现方式：现代处理器的<strong>向量功能部件</strong>、<strong>向量处理器</strong>、多处理器中<strong>SPMD编程</strong>。</li>
</ol>
<h3 id="1013-任务级并行">10.1.3 任务级并行</h3>
<ol>
<li>任务级并行是<strong>将不同的任务（进程或线程）分布到不同的处理单元上执行</strong>。</li>
<li>分类：<strong>进程级并行、线程级并行</strong>。</li>
<li>实现方式：<strong>让不同处理器执行不同的进程或线程</strong>。</li>
<li>应用：商业应用领域、多道程序工作负载(Multiprogramming Workload)。</li>
</ol>
<h2 id="102-并行编程模型">10.2 并行编程模型</h2>
<p>分为<strong>单任务</strong>和<strong>多任务</strong>并行模型。单任务并行模型包括<strong>单任务数据并行模型</strong>；多任务并行模型包括<strong>多任务共享存储编程模型</strong> 和 <strong>多任务消息传递编程模型</strong>。</p>
<h3 id="1021-单任务数据并行模型">10.2.1 单任务数据并行模型</h3>
<ol>
<li>数据级并行在<strong>SIMD计算机</strong>上实现，着重开发<strong>指令级</strong>并行，为<strong>单任务数据并行</strong>；在<strong>SPMD计算机</strong>上实现，着重开发<strong>子程序级</strong>并行，为<strong>多任务数据并行</strong>。</li>
<li>特点：<strong>单线程、同构并行、全局命名空间、隐式相互作用、隐式数据分配</strong>。</li>
</ol>
<h3 id="1022-多任务共享存储编程模型">10.2.2 多任务共享存储编程模型</h3>
<ol>
<li>运行在各处理器上的进程/线程通过读写共享存储器上的<strong>共享变量</strong>来进行通信。</li>
<li>特点：<strong>多线程异步执行、单一的全局名字空间、隐式数据分配、显式或隐式负载分配、显式同步</strong>。</li>
<li>常见模型：Pthreads、OpenMP等。</li>
</ol>
<h3 id="1023-多任务消息传递编程模型">10.2.3 多任务消息传递编程模型</h3>
<ol>
<li>不同处理器上的进程/线程拥有独立的地址空间，通过<strong>网络传递消息</strong>来相互通信。</li>
<li>特点：<strong>多进程异步执行、独立的地址空间、显式相互作用、显式分配</strong>。</li>
<li>常见模型：MPI、PVM。</li>
</ol>
<h3 id="1024-共享存储与消息传递编程模型的编程复杂度">10.2.4 共享存储与消息传递编程模型的编程复杂度</h3>
<ol>
<li>共享存储中，所有处理器共享同一个<strong>主存储器</strong>，<strong>统一编址</strong>；消息传递中，每个处理器有一个它自己才能访问的<strong>局部存储器</strong>，每个存储器<strong>单独编址</strong>。</li>
<li>共享存储中，程序员只需要对<strong>计算任务</strong>进行划分；消息传递中，程序员需要对<strong>计算任务、数据</strong>进行划分，并安排<strong>进程间的所有通信</strong>。</li>
</ol>
<h2 id="103-典型并行编程环境">10.3 典型并行编程环境</h2>
<p>数据并行：SIMD</p>
<p>共享存储编程模型：Pthreads和OpenMP</p>
<p>消息传递编程模型：MPI</p>
<h3 id="1031-数据并行simd编程">10.3.1 数据并行SIMD编程</h3>
<p>向量指令（vld, vadd.b, vst等），利用向量寄存器实现。龙芯的向量寄存器复用了浮点寄存器。</p>
<h3 id="1032-pthreads">10.3.2 Pthreads</h3>
<p>C语言的一套函数库。利用<code>pthread_create</code>, <code>pthread_join</code>, <code>pthread_exit</code>, <code>pthread_self</code><strong>管理线程</strong>，利用<code>pthread_yield</code>, <code>pthread_cancel</code><strong>调度线程</strong>，利用<code>pthread_mutex_init</code>, <code>pthread_mutex_lock/unlock</code>, <code>pthread_cond_init</code>, <code>pthread_cond_wait/signal/broadcast</code>等<strong>同步线程</strong>。</p>
<h3 id="1033-openmp">10.3.3 OpenMP</h3>
<ul>
<li>主要 API：制导指令、运行库、环境变量。</li>
<li>常见子句：
<ul>
<li>共享：<code>shared(var1, var2, ...)</code></li>
<li>私有：<code>private(var1, var2, ...)</code></li>
<li>归约：<code>reduction(op:var)</code></li>
</ul>
</li>
</ul>
<p>例如，<code>#pragma omp parallel for private(i, x), reduction(+:sum)</code>语句表示在接下来的循环中，使用多个线程并行执行，并设置<code>i</code>和<code>x</code>变量为私有，<code>sum</code>变量为归约变量。</p>
<h3 id="1034-mpi">10.3.4 MPI</h3>
<ol>
<li>
<p>主要API：6个基本函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">函数名</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">MPI_Init</td>
<td style="text-align:left">初始化MPI执行环境</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">MPI_Finalize</td>
<td style="text-align:left">结束MPI执行环境</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">MPI_Comm_size</td>
<td style="text-align:left">确定进程数</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">MPI_Comm_rank</td>
<td style="text-align:left">确定自己的进程标识符</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">MPI_Send</td>
<td style="text-align:left">发送一条消息</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">MPI_Recv</td>
<td style="text-align:left">接收一条消息</td>
</tr>
</tbody>
</table>
<blockquote>
<p>comm代表communicator，通信域。通信域包含进程组和通信上下文。</p>
</blockquote>
</li>
<li>
<p>点对点通信方式：<strong>阻塞方式</strong>和<strong>非阻塞方式</strong>。前者等消息从本地送出后才继续执行，保证缓冲区等资源可再用；后者不等消息从本地送出就继续执行，不保证缓冲区等资源可再用。</p>
</li>
<li>
<p>四种通信模式：</p>
<ul>
<li><strong>标准模式</strong>：由MPI决定后面三种模式选哪一种；</li>
<li><strong>缓冲模式</strong>：使用缓存存储消息，发送与接收无关；</li>
<li><strong>同步模式</strong>：等接收开始后，发送才能返回；</li>
<li><strong>就绪模式</strong>：等接收启动后，发送才能开始。</li>
</ul>
</li>
<li>
<p>集体通信(Collective Communication)：</p>
<ul>
<li><strong>栅障(MPI_Barrier)</strong></li>
<li><strong>广播(MPI_Bcast)</strong></li>
<li><strong>收集(MPI_Gather)</strong></li>
<li><strong>散播(MPI_Scatter)</strong></li>
<li><strong>归约(MPI_Reduce, MPI_Allreduce)</strong></li>
</ul>
</li>
</ol>
<h1 id="第11章-多核处理结构">第11章 多核处理结构</h1>
<h2 id="111-多核处理器的发展演化">11.1 多核处理器的发展演化</h2>
<ul>
<li><strong>提出背景</strong></li>
</ul>
<ol>
<li><strong>半导体工艺</strong>：摩尔定律放慢、面临失效。且工艺提升对性能带来的红利在缩小。</li>
<li><strong>功耗墙</strong>：提高单核性能功耗开销比多核大。</li>
<li><strong>并行结构的发展</strong>：SIMD、SMP、CC-NUMA、MPP结构……</li>
</ol>
<blockquote>
<ul>
<li><strong>GPU采用什么结构？</strong></li>
</ul>
<p>GPU（图形处理器）采用<strong>流水线结构</strong>来实现并行化。流水线结构包括一组处理器，每个处理器都有一个特定的角色，它们协同工作，按照一定顺序处理数据。SM（Streaming Multiprocessor）是 GPU 中的一种基本组成单元，通常称为“<strong>流处理器</strong>”。SM 包含多个处理器核心，用于执行并行计算。</p>
<p>流水线结构是将一个大任务分解成若干个小任务，并将这些小任务分配给不同的流水线处理器来实现并行化，而 SM 就是这样的一个流水线处理器。</p>
</blockquote>
<ul>
<li><strong>分类方式</strong></li>
</ul>
<ol>
<li>按照<strong>从核数量</strong>：<strong>多核处理器</strong>和<strong>众核处理器</strong>（一般指多于64核的处理器）；</li>
<li>按照<strong>处理器核结构</strong>：<strong>同构</strong>和<strong>异构</strong>；</li>
<li>按照<strong>适用应用</strong>：<strong>通用</strong>和<strong>专用</strong>（GPU可以看作是一种专用多核处理器，具有很高的浮点峰值运算性能）。</li>
</ol>
<ul>
<li><strong>流行的CPU结构</strong></li>
</ul>
<ol>
<li><strong>多核+向量处理</strong></li>
<li><strong>众核</strong>（GPU是其中一种，同构）</li>
<li><strong>带有协处理器的异构多核</strong></li>
</ol>
<ul>
<li><strong>存储结构</strong>：通用多核处理器一般采用<strong>共享存储结构</strong>。</li>
</ul>
<h2 id="112-多核处理器的访存结构">11.2 多核处理器的访存结构</h2>
<p>需要关心的问题：</p>
<ol>
<li><strong>存储一致性</strong>：多核处理器的访存指令次序如何约定？</li>
<li><strong>片上Cache结构</strong>：Cache结构采用私有还是共享？集中式还是分布式？</li>
<li><strong>Cache一致性</strong>：一个数据可能在多个处理器的私有Cache中和内存中存在备份，如何保证数据一致性？</li>
</ol>
<h3 id="1121-片上cache结构">11.2.1 片上Cache结构</h3>
<ol>
<li>主流结构：<strong>片内共享LLC，片间共享内存</strong>。</li>
<li>共享LLC结构中，主要有<strong>UCA</strong>和<strong>NUCA</strong>结构。</li>
</ol>
<h3 id="1122-存储一致性模型">11.2.2 存储一致性模型</h3>
<ul>
<li><strong>顺序一致性模型</strong>；在顺序一致性约束下，多处理机的表现与对应的单处理机多进程表现一致（和OS中研究的那种表现一致）。</li>
<li><strong>处理器一致性模型</strong>：在任意load开始执行前，先于它的load操作都要完成；在任意store开始执行前，先于它的load和store操作都已完成。换句话说，可以在某个load执行时，先于它的store操作还没有执行或没有执行完。也就是允许load越过store操作执行。实际上是把write buffer变得让用户可见。</li>
<li><strong>弱一致性模型</strong>：同步操作和访存操作满足顺序一致性，也就是说，同步操作执行前的访存操作都已完成，访存操作执行前的同步操作都已完成。</li>
<li><strong>释放一致性模型</strong>：把同步操作拆分成acquire和release操作。同步操作满足顺序一致性。release操作执行前的访存操作都已完成（收工之后才能释放锁），访存操作执行前的acquire操作都已完成（可以进到临界区）。</li>
</ul>
<h3 id="1123-cache一致性协议">11.2.3 Cache一致性协议</h3>
<ol>
<li>定义：一种<strong>把新写的值传播到其它处理器核</strong>的机制。</li>
<li>分类：
<ul>
<li><strong>如何传播</strong>：<strong>写无效</strong>(Write Invalidate)和<strong>写更新</strong>(Write Update);</li>
<li><strong>向谁传播</strong>：<strong>侦听协议</strong>(Snoopy)和<strong>目录协议</strong>(Directory)。</li>
</ul>
</li>
<li>写无效协议与写更新协议：
<ul>
<li><strong>写无效协议</strong>：某个处理器Cache值更新时，先令其它处理器中相应单元的值标记为无效，等其他处理器要用到该单元时，再更新为新值。</li>
<li><strong>写更新协议</strong>：某个处理器Cache值更新时，即把新值更新到其它处理器的Cache中。</li>
</ul>
</li>
<li>侦听协议与目录协议：
<ul>
<li><strong>侦听协议</strong>：写数的处理机<strong>把新写的值或要读取的地址广播出去</strong>；其它处理机<strong>侦听广播</strong>，广播中内容与自己有关时<strong>接受新值或提供数据</strong>。适用于<strong>总线互连结构</strong>。</li>
<li><strong>目录协议</strong>：每个Cache存储行都维护一个目录项，目录项记录了<strong>每个处理器核是否含有该行的备份</strong>。目录项另有一个<strong>改写位</strong>，记录是否有某个处理器改写了改行。可以避免广播，但是存储开销大，需要动态维护。</li>
</ul>
</li>
<li>Cache状态：Cache一致性协议是通过维护每个Cache行的一致性状态来实现的。具体有ESI、MESI和MOESI，其中ESI最简单，MESI较常见。</li>
<li><strong>ESI</strong>：<strong>（※ESI状态转换重要）</strong>
<ul>
<li>E（Exclusive，独占）：对应Cache行被当前处理器核独占。其它处理器核需要等当前处理器释放；</li>
<li>S（Shared，共享）：多处理器核共享，因此是只读的。</li>
<li>I（Invalid，无效）：当前Cache行无效。</li>
</ul>
</li>
<li><strong>MESI</strong>：增加M状态。这时，E状态修改为，当前Cache行虽然被独占，但是还没有被修改；M状态自然表示被独占且已经被修改。</li>
<li>存储一致性与Cache一致性：Cache一致性都是针对某种存储一致性设计的。常用弱一致性模型。</li>
</ol>
<h2 id="113-互连结构">11.3 互连结构</h2>
<ol>
<li>常见片上互连结构：<strong>片上总线、交叉开关、片上网络</strong>。</li>
<li>连接<strong>处理器核、Cache、内存控制器、IO接口等</strong>模块。</li>
</ol>
<h3 id="1131-片上总线">11.3.1 片上总线</h3>
<ol>
<li>由<strong>一组信号线</strong>连接各功能模块。</li>
<li>包括<strong>数据总线、地址总线、控制总线</strong>等。</li>
<li>优点：实现简单-&gt;利于<strong>广播通信</strong>。</li>
<li>缺点：独立资源-&gt;<strong>可伸缩性差</strong>。</li>
<li>结点间采用<strong>握手方式</strong>建立<strong>直通链路</strong>。</li>
</ol>
<h3 id="1132-交叉开关">11.3.2 交叉开关</h3>
<ol>
<li>以<strong>矩阵形式</strong>组织的开关，任意输入端口可以接上任意输出端口。</li>
<li>具有<strong>非阻塞</strong>特性，在不冲突的前提下可以建立多个输入输出连接。</li>
<li>优点：并行非阻塞通信-&gt;<strong>高带宽</strong>。</li>
<li>缺点：复杂度为O(mn)-&gt;<strong>可伸缩性有限</strong>。</li>
<li>结点间采用<strong>握手方式</strong>建立<strong>直通链路</strong>。</li>
</ol>
<h3 id="1133-片上网络">11.3.3 片上网络</h3>
<ul>
<li><strong>概念</strong></li>
</ul>
<ol>
<li>数据封装成<strong>数据包</strong>，通过<strong>路由器</strong>之间的<strong>分组交换</strong>和<strong>存储转发机制</strong>实现处理器核间通信。</li>
<li>抽象成<strong>节点、互连网络、网络接口</strong>。</li>
<li>研究内容：<strong>拓扑结构、路由算法、流量控制</strong>。</li>
</ol>
<ul>
<li><strong>拓扑结构</strong></li>
</ul>
<p>环(ring)、网格(mesh)。</p>
<ul>
<li><strong>路由算法</strong></li>
</ul>
<ol>
<li>环的路由方法：只有唯一一种。</li>
<li>Mesh网的路由方法：维序路由（一路走到头）、全局自适应路由（优选负载较轻方向）。</li>
</ol>
<ul>
<li><strong>路由器结构</strong></li>
</ul>
<ol>
<li>路由器由<strong>寄存器、交叉开关、功能单元和控制逻辑</strong>组成。</li>
<li>适合Mesh结构的路由器：输入端口连接buffer；分配器管理buffer和交叉开关；buffer连接到交叉开关，从而连接到输出上。</li>
<li>分配器作用：<strong>路由计算、虚通道分配、交叉开关分配</strong>。</li>
<li>数据包传输有四个流水级：路由计算(RC)、虚通道分配(VA)、交叉开关分配(SA)、交叉开关上传输(ST)。head flit经过四个流水级，body flit经过后两个流水级。</li>
</ol>
<ul>
<li><strong>流量控制</strong></li>
</ul>
<ol>
<li>片上网络的主要资源：<strong>信道和缓冲区</strong>。</li>
<li>好的流量控制策略：<strong>公平性和无死锁</strong>。</li>
<li>每个结点都有向相邻节点发送数据的<strong>缓冲区Buffer</strong>，和记录相邻节点缓冲区使用量的<strong>计数器S[0-3]</strong>。流量控制方法详见课本。</li>
</ol>
<h2 id="114-多核处理器的同步机制">11.4 多核处理器的同步机制</h2>
<ol>
<li>对<strong>共享变量</strong>需要进行同步，否则同一个并行程序可能在不同的运行中产生不同的结果。</li>
<li>三种常见的同步机制：<strong>锁、栅障、事务内存</strong>。</li>
<li>常用<strong>硬件同步指令</strong>实现上述同步机制。</li>
</ol>
<h3 id="1141-硬件同步指令">11.4.1 硬件同步指令</h3>
<p>主要是<b>“读-改-写”指令和“LL/SC”指令</b>。</p>
<ul>
<li><strong>读-改-写</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Test_and_Set</code></td>
<td style="text-align:left">取出对应地址上的值，并为其赋一个新值。</td>
</tr>
<tr>
<td style="text-align:left"><code>Swap</code></td>
<td style="text-align:left">交换两个地址上的值。</td>
</tr>
<tr>
<td style="text-align:left"><code>Compare_and_Swap</code></td>
<td style="text-align:left">如果对应地址上的值和A相等，则把B赋给这个地址，否则这个地址的值不动。</td>
</tr>
<tr>
<td style="text-align:left"><code>Fetch_and_Op</code></td>
<td style="text-align:left">取出对应地址上的值，进行某种运算Op，然后存回去。</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>LL/SC</strong></li>
</ul>
<p>LL指令将某个地址上的值读取到寄存器中，并将LLbit置为1。</p>
<p>LL执行完但SC指令尚未执行时，如果该地址上的值被其他处理器访问，或者执行了eret操作，则将LLbit置为0。</p>
<p>SC指令检查LLbit，如果是1，则将寄存器的值更新到该地址上，并且把寄存器的值重新设为1，表示成功；否则不更新该地址上的值，并把寄存器的值重新设为0，表示失败。</p>
<p>如果失败，一般需要回到开头LL处，重新执行。</p>
<h3 id="1142-锁">11.4.2 锁</h3>
<ol>
<li>使用<code>Test_and_Set</code>实现，是一种基本的实现方式。</li>
<li>缺点：获取锁失败时要循环访问，产生大量片上互连通信。</li>
<li>解决方式：可以在相邻两次循环访问之间引入延迟。</li>
</ol>
<h3 id="1143-栅障">11.4.3 栅障</h3>
<ol>
<li>
<p>使用<code>Fetch_and_Inc</code>实现：</p>
<pre><code class="language-c">barrier(){
    Fetch_and_Inc(count);
    while(count != Max) ;
}
</code></pre>
</li>
<li>
<p>缺点：与自旋锁相同，有大量通信。</p>
</li>
</ol>
<h3 id="1144-事务内存">11.4.4 事务内存</h3>
<ol>
<li>事务：事务内存中，<strong>访问共享变量</strong>的代码区域声明为一个事务。</li>
<li>事务的性质：
<ul>
<li><strong>原子性</strong>：这个代码区域中的所有指令要么都执行要么都不执行。</li>
<li><strong>一致性</strong>：任何时刻内存一致。</li>
<li><strong>隔离性</strong>：不同事务内部对象状态互不可见。事务执行结束后，如果执行成功，将所有结果提交到内存中；如果执行失败，中止并取消所有结果。</li>
</ul>
</li>
<li>实现方式：
<ul>
<li><strong>软件事务内存</strong>：库函数或编程语言；</li>
<li><strong>硬件事务内存</strong>：主要对多核处理器的Cache结构进行改造。例如Intel TSX新增了三条指令XBEGIN, XEND和XABORT，以Cache行为单位跟踪事务的读集和写集。</li>
</ul>
</li>
</ol>
<h3 id="115-典型多核处理器">11.5 典型多核处理器</h3>
<h1 id="第12章-计算机系统评价和性能分析">第12章 计算机系统评价和性能分析</h1>
<ol>
<li>性能最本质的定义：<strong>完成一个任务所需要的时间</strong>。</li>
<li>性能分析方法：<strong>分析、模拟、测量</strong>。</li>
</ol>
<h2 id="121-计算机系统性能评价指标">12.1 计算机系统性能评价指标</h2>
<ol>
<li>
<p>不同系统所关注的性能：</p>
<ul>
<li><strong>桌面计算机</strong>：大文件压缩、音视频播放……</li>
<li><strong>Web服务器</strong>：每秒所完成的Web请求数，衡量指标是吞吐率（每秒完成的交易事务）。</li>
<li><strong>高性能计算机</strong>：衡量指标是完成一个大的并行任务的速度。</li>
</ul>
</li>
<li>
<p>影响性能的因素：<strong>应用</strong>（影响最大，不同系统各有所长各有所短）、<strong>算法、编译系统、指令系统、微结构</strong>（影响IPC、主频）、<strong>工艺</strong>（主要影响主频）。</p>
</li>
<li>
<p>常见性能指标：CPI、 MIPS、 MFLOPS、 TPS、 FPS、 MBPS、 MHz</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">全称</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CPI</td>
<td style="text-align:left">Cycles Per Instruction</td>
<td style="text-align:left">每条指令的时钟周期数</td>
</tr>
<tr>
<td style="text-align:left">MIPS</td>
<td style="text-align:left">Millon Instructions Per Second</td>
<td style="text-align:left">每秒执行百万条指令数</td>
</tr>
<tr>
<td style="text-align:left">MFLOPS</td>
<td style="text-align:left">Mllion Floating Point Operations Per Second</td>
<td style="text-align:left">每秒执行 百万浮点运算数</td>
</tr>
<tr>
<td style="text-align:left">TPS</td>
<td style="text-align:left">Transactions Per Second</td>
<td style="text-align:left">每秒执行的事务数</td>
</tr>
<tr>
<td style="text-align:left">FPS</td>
<td style="text-align:left">Frames Per Second</td>
<td style="text-align:left">每秒帧数</td>
</tr>
<tr>
<td style="text-align:left">MBPS</td>
<td style="text-align:left">MB Per Second</td>
<td style="text-align:left">每秒完成多少MB的访存操作，带宽的单位</td>
</tr>
<tr>
<td style="text-align:left">MHz</td>
<td style="text-align:left">-</td>
<td style="text-align:left">兆赫兹，主频的单位</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>CPU时间 = <strong>指令数 × IPC × 主频</strong></p>
<ul>
<li><strong>指令数</strong>：算法、编译器、ISA</li>
<li><strong>IPC</strong>：微结构、编译器、ISA</li>
<li><strong>主频</strong>：微结构、工艺技术、逻辑设计（如串行进位和并行进位加法器）、物理设计（如动态电路的使用）</li>
</ul>
</li>
<li>
<p>并行系统的评价指标：<strong>可扩展性、加速比</strong>。</p>
</li>
<li>
<p><strong>阿姆达尔定律</strong>：系统中对某一部分改进后获得的整体性能提升程度，取决于部分被使用的频率，或所占总执行时间的比例。</p>
</li>
</ol>
<h2 id="122-测试程序集黑盒法">12.2 测试程序集（黑盒法）</h2>
<ol>
<li>特点：
<ul>
<li><strong>公平性</strong>：拿程序来测，看看实际性能表现，而不是只看个别技术指标。</li>
<li><strong>侧重性</strong>：不同计算机侧重点不同，需要不同的测试程序。</li>
<li><strong>全面性</strong>：测试程序要有代表性，覆盖面足够广。</li>
<li><strong>公开性</strong>：测试报告要详细，便于查阅。</li>
</ul>
</li>
<li>常见基准测试程序类型：
<ul>
<li><strong>微基准测试程序</strong>：Sim-alpha的microbench, LMbench, STREAM, CoreMark, UnixBench等。</li>
<li><strong>串行CPU基准测试程序</strong>：SPEC CPU, EEMBC。</li>
<li><strong>并行CPU基准测试程序</strong>：SPLASH-2（测并行加速比）, PARSEC（测并行加速比）, Linpack（测并行浮点峰值）。</li>
<li><strong>专项基准测试程序</strong>：SPEC jvm, SPEC jbb, SPECSFS, SPEC viewperf, TPC。</li>
</ul>
</li>
<li><strong>微（基准）测试程序</strong>：小的测试程序，能在短时间内跑完，可以用于处理器某些模块的专门优化。</li>
</ol>
<h2 id="123-性能分析方法白盒法">12.3 性能分析方法（白盒法）</h2>
<ol>
<li>分类：
<ul>
<li><strong>性能建模</strong>
<ul>
<li><strong>分析建模</strong>：概率模型、队列模型、马尔可夫模型、Petri网模型。</li>
<li><strong>模拟建模</strong>：踪迹驱动模拟、执行驱动模拟、全系统模拟、事件驱动模拟、统计方法模拟。</li>
</ul>
</li>
<li><strong>性能测量</strong>：片上硬件监测器（如性能计数器）、片外硬件监测器、软件监测器、微码插桩。</li>
</ul>
</li>
<li><strong>基于分析和统计的建模（分析建模）</strong>：基于对处理器结构和程序特性的分析，建立处理器的性能公式，通过数学公式计算出处理器的性能信息。</li>
<li><strong>基于模拟的建模（模拟建模）</strong>：用高级语言编写模拟器，模拟CPU进行建模。是处理器设计中用得最为广泛的方法。</li>
<li><strong>常用的模拟器</strong>：SimpleScalar, SimOS, GEM5, IBM的Mambo和Turandot, AMD的SimNow等。有两种分类：
<ul>
<li><strong>系统模拟器和部件模拟器</strong></li>
<li><strong>全系统模拟器和用户态模拟器</strong></li>
</ul>
</li>
<li><strong>模拟加速技术</strong>：在模拟速度和精度之间折中。代表性技术是<strong>采样模拟技术</strong>和<strong>统计模拟技术</strong>。
<ul>
<li><strong>采样模拟技术</strong>：截取程序的一小部分进行模拟，近似代表整个程序的模拟结果。SMART：周期采样；SimPoint：采样能够代表每个相位的部分。</li>
<li><strong>统计模拟技术</strong>：用统计方法分析工作负载，得出多种类型的统计信息，由此生成合成的程序踪迹，包含有工作负载抽象提炼出的信息，因此能在模拟器上很快地收敛。</li>
</ul>
</li>
<li>模拟器和真实系统的绝对误差是无法避免的，但是模拟结果和真是系统的偏差是稳定的，可以用同一个模拟器模拟多个不同的系统来进行相对比较。</li>
<li><strong>性能计数器的优势</strong>：可以统计复杂应用的行为，实时监测系统行为（模拟器办不到，只能运行简单的程序）。</li>
<li><strong>Perf性能分析工具</strong>：集成在Linux系统中的性能分析工具，基于事件采样原理，采样硬件事件、软件事件、tracepoint触发的事件。</li>
</ol>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://kimokcheon.github.io/post/python/" class="post-title gt-a-link">
                    Python
                </a>
            </div>
        

        

        

        
            <script src='https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'></script>

<style>
	div#vcomments{
		width:100%;
		max-width: 1000px;
		padding: 2.5%
	}
</style>


	<div id="vcomments"></div>

<script>
	new Valine({
		el: '#vcomments',
		appId: '',
		appKey: '',
		avatar: '',
		pageSize: 5,
		recordIp: false,
		placeholder: 'Just Go Go',
		visitor: false,
	});
</script>

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">他们都是萤火，聚在一起就成了太阳</div>
    <div class="social-container">
        
            
                <a href="https://github.com/Kimokcheon" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/people/deng-yu-chuan-4" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://kimokcheon.github.io//atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
